//
// Generated by @himenon/openapi-typescript-code-generator v0.4.0
//
// OpenApi : 3.0.0
//
// License  : Twitter Developer Agreement and Policy
// Url      : https://developer.twitter.com/en/developer-terms/agreement-and-policy.html
//


export namespace Schemas {
    /** The height of the media in pixels */
    export type MediaHeight = number;
    /** The width of the media in pixels */
    export type MediaWidth = number;
    /** HTTP Status Code. */
    export type HTTPStatusCode = number;
    /** Annotation inferred from the tweet text. */
    export interface ContextAnnotation {
        domain: Schemas.ContextAnnotationDomainFields;
        entity: Schemas.ContextAnnotationEntityFields;
    }
    /** Represents the data for the context annotation domain. */
    export interface ContextAnnotationDomainFields {
        /** The unique id for a context annotation domain. */
        id: string;
        /** Name of the context annotation domain. */
        name?: string;
        /** Description of the context annotation domain. */
        description?: string;
    }
    /** Represents the data for the context annotation entity. */
    export interface ContextAnnotationEntityFields {
        /** The unique id for a context annotation entity. */
        id: string;
        /** Name of the context annotation entity. */
        name?: string;
        /** Description of the context annotation entity. */
        description?: string;
    }
    /** A validly formatted URL. */
    export type URL = string;
    /** Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`. */
    export interface EntityIndices {
        /** Index (zero-based) at which position this entity starts. */
        start: number;
        /** Index (zero-based) at which position this entity ends. */
        end: number;
    }
    /** Represent the portion of text recognized as a URL. */
    export interface URLFields {
        url: Schemas.URL;
        expanded_url?: Schemas.URL;
        /** The URL as displayed in the Twitter client. */
        display_url?: string;
        /** Fully resolved url */
        unwound_url?: string;
        status?: Schemas.HTTPStatusCode;
        /** Title of the page the URL points to. */
        title?: string;
        /** Description of the URL landing page. */
        description?: string;
        images?: Schemas.URLImage[];
    }
    export type UrlEntity = Schemas.EntityIndices & Schemas.URLFields;
    /** Represent the information for the URL image */
    export interface URLImage {
        url?: Schemas.URL;
        height?: Schemas.MediaHeight;
        width?: Schemas.MediaWidth;
    }
    /** Represent the portion of text recognized as a Hashtag, and its start and end position within the text. */
    export interface HashtagFields {
        /** The text of the Hashtag */
        tag: string;
    }
    export type HashtagEntity = Schemas.EntityIndices & Schemas.HashtagFields;
    /** Represent the portion of text recognized as a Cashtag, and its start and end position within the text. */
    export interface CashtagFields {
        tag: string;
    }
    export type CashtagEntity = Schemas.EntityIndices & Schemas.CashtagFields;
    /** Represent the portion of text recognized as a User mention, and its start and end position within the text. */
    export interface MentionFields {
        username: Schemas.UserName;
    }
    export type MentionEntity = Schemas.EntityIndices & Schemas.MentionFields;
    export interface FullTextEntities {
        urls?: Schemas.UrlEntity[];
        hashtags?: Schemas.HashtagEntity[];
        mentions?: Schemas.MentionEntity[];
        cashtags?: Schemas.CashtagEntity[];
    }
    /** Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers. */
    export type TweetID = string;
    /** Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers. */
    export type UserID = string;
    /** Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following. */
    export type ReplySettings = "everyone" | "mentionedUsers" | "following" | "other";
    export interface Error {
        code: number;
        message: string;
    }
    export interface Expansions {
        users?: Schemas.User[];
        tweets?: Schemas.Tweet[];
        places?: Schemas.Place[];
        media?: Schemas.Media[];
        polls?: Schemas.Poll[];
    }
    export interface Tweet {
        id: Schemas.TweetID;
        /** Creation time of the Tweet. */
        created_at?: string;
        /** The content of the Tweet. */
        text: string;
        author_id?: Schemas.UserID;
        in_reply_to_user_id?: Schemas.UserID;
        conversation_id?: Schemas.TweetID;
        reply_settings?: Schemas.ReplySettings;
        /** A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent. */
        referenced_tweets?: {
            type: "retweeted" | "quoted" | "replied_to";
            id: Schemas.TweetID;
        }[];
        /** Specifies the type of attachments (if any) present in this Tweet. */
        attachments?: {
            /** A list of Media Keys for each one of the media attachments (if media are attached). */
            media_keys?: Schemas.MediaKey[];
            /** A list of poll IDs (if polls are attached). */
            poll_ids?: Schemas.PollId[];
        };
        context_annotations?: Schemas.ContextAnnotation[];
        withheld?: Schemas.TweetWithheld;
        /** The location tagged on the Tweet, if the user provided one. */
        geo?: {
            coordinates?: Schemas.Point;
            place_id?: Schemas.PlaceId;
        };
        entities?: Schemas.FullTextEntities;
        /** Engagement metrics for the Tweet at the time of the request. */
        public_metrics?: {
            /** Number of times this Tweet has been Retweeted. */
            retweet_count: number;
            /** Number of times this Tweet has been replied to. */
            reply_count: number;
            /** Number of times this Tweet has been liked. */
            like_count: number;
            /** Number of times this Tweet has been quoted. */
            quote_count?: number;
        };
        /** Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences. */
        possibly_sensitive?: boolean;
        /** Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag. */
        lang?: string;
        /** The name of the app the user Tweeted from. */
        source?: string;
        /** Nonpublic engagement metrics for the Tweet at the time of the request. */
        non_public_metrics?: {
            /** Number of times this Tweet has been viewed. */
            impression_count?: number;
        };
        /** Promoted nonpublic engagement metrics for the Tweet at the time of the request. */
        promoted_metrics?: {
            /** Number of times this Tweet has been viewed. */
            impression_count?: number;
            /** Number of times this Tweet has been liked. */
            like_count?: number;
            /** Number of times this Tweet has been replied to. */
            reply_count?: number;
            /** Number of times this Tweet has been Retweeted. */
            retweet_count?: number;
        };
        /** Organic nonpublic engagement metrics for the Tweet at the time of the request. */
        organic_metrics?: {
            /** Number of times this Tweet has been viewed. */
            impression_count: number;
            /** Number of times this Tweet has been Retweeted. */
            retweet_count: number;
            /** Number of times this Tweet has been replied to. */
            reply_count: number;
            /** Number of times this Tweet has been liked. */
            like_count: number;
        };
    }
    /** The Twitter User object */
    export interface User {
        id: Schemas.UserID;
        /** Creation time of this user. */
        created_at?: string;
        /** The friendly name of this user, as shown on their profile. */
        name: string;
        username: Schemas.UserName;
        /** Indicates if this user has chosen to protect their Tweets (in other words, if this user's Tweets are private). */
        protected?: boolean;
        /** Indicate if this user is a verified Twitter User. */
        verified?: boolean;
        withheld?: Schemas.UserWithheld;
        /** The URL to the profile image for this user. */
        profile_image_url?: string;
        /** The location specified in the user's profile, if the user provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries. */
        location?: string;
        /** The URL specified in the user's profile. */
        url?: string;
        /** The text of this user's profile description (also known as bio), if the user provided one. */
        description?: string;
        /** A list of metadata found in the user's profile description. */
        entities?: {
            /** Expanded details for the URL specified in the user's profile, with start and end indices. */
            url?: {
                urls?: Schemas.UrlEntity[];
            };
            description?: Schemas.FullTextEntities;
        };
        pinned_tweet_id?: Schemas.TweetID;
        /** A list of metrics for this user */
        public_metrics?: {
            /** Number of users who are following this user. */
            followers_count: number;
            /** Number of users this user is following. */
            following_count: number;
            /** The number of Tweets (including Retweets) posted by this user. */
            tweet_count: number;
            /** The number of lists that include this user. */
            listed_count: number;
        };
    }
    /** The Twitter handle (screen name) of this user. */
    export type UserName = string;
    export interface UserLookupResponse {
        data?: Schemas.User[];
        includes?: Schemas.Expansions;
        errors?: Schemas.Problem[];
    }
    export interface SingleUserLookupResponse {
        data?: Schemas.User;
        includes?: Schemas.Expansions;
        errors?: Schemas.Problem[];
    }
    export interface TweetLookupResponse {
        data?: Schemas.Tweet[];
        includes?: Schemas.Expansions;
        errors?: Schemas.Problem[];
        meta?: {
            /** The next cursor provided by the response. */
            next_token?: string;
            /** The ID of the oldest Tweet in the response. */
            oldest_id?: string;
            /** The ID of the newest Tweet in the response. */
            newest_id?: string;
            /** The previous cursor provided by the response. */
            previous_token?: string;
            /** Number of results returned in the response. */
            result_count?: number;
        };
    }
    export interface SingleTweetLookupResponse {
        data?: Schemas.Tweet;
        includes?: Schemas.Expansions;
        errors?: Schemas.Problem[];
    }
    /** A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object. */
    export interface Point {
        type: "Point";
        coordinates: Schemas.Position;
    }
    /** A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`. */
    export type Position = number[];
    export interface Geo {
        type: "Feature";
        bbox: number[];
        geometry?: Schemas.Point;
        properties: {};
    }
    /** The identifier for this place */
    export type PlaceId = string;
    export interface Place {
        id: Schemas.PlaceId;
        /** The human readable name of this place. */
        name?: string;
        country_code?: Schemas.CountryCode;
        place_type?: Schemas.PlaceType;
        full_name: string;
        country?: string;
        contained_within?: Schemas.PlaceId[];
        geo?: Schemas.Geo;
    }
    export type PlaceType = "poi" | "neighborhood" | "city" | "admin" | "country" | "unknown";
    /** Represent a Poll attached to a Tweet */
    export interface Poll {
        id: Schemas.PollId;
        options: Schemas.PollOption[];
        voting_status?: "open" | "closed";
        end_datetime?: string;
        duration_minutes?: number;
    }
    /** Unique identifier of this poll. */
    export type PollId = string;
    /** Describes a choice in a Poll object. */
    export interface PollOption {
        /** Position of this choice in the poll. */
        position: number;
        /** The text of a poll choice. */
        label: string;
        /** Number of users who voted for this choice. */
        votes: number;
    }
    export interface CommonMediaFields {
        media_key?: Schemas.MediaKey;
        height?: Schemas.MediaHeight;
        width?: Schemas.MediaWidth;
    }
    export type Media = Schemas.Photo | Schemas.Video | Schemas.AnimatedGif;
    export type Photo = Schemas.CommonMediaFields & {
        type?: "photo";
        url?: string;
    };
    export type Video = Schemas.CommonMediaFields & {
        type?: "video";
        preview_image_url?: string;
        duration_ms?: number;
        /** Engagement metrics for the Media at the time of the request. */
        public_metrics?: {
            /** Number of times this video has been viewed. */
            view_count?: number;
        };
        /** Nonpublic engagement metrics for the Media at the time of the request. */
        non_public_metrics?: {
            /** Number of users who made it through 0% of the video. */
            playback_0_count?: number;
            /** Number of users who made it through 25% of the video. */
            playback_25_count?: number;
            /** Number of users who made it through 50% of the video. */
            playback_50_count?: number;
            /** Number of users who made it through 75% of the video. */
            playback_75_count?: number;
            /** Number of users who made it through 100% of the video. */
            playback_100_count?: number;
        };
        /** Organic nonpublic engagement metrics for the Media at the time of the request. */
        organic_metrics?: {
            /** Number of users who made it through 0% of the video. */
            playback_0_count?: number;
            /** Number of users who made it through 25% of the video. */
            playback_25_count?: number;
            /** Number of users who made it through 50% of the video. */
            playback_50_count?: number;
            /** Number of users who made it through 75% of the video. */
            playback_75_count?: number;
            /** Number of users who made it through 100% of the video. */
            playback_100_count?: number;
            /** Number of times this video has been viewed. */
            view_count?: number;
        };
        /** Promoted nonpublic engagement metrics for the Media at the time of the request. */
        promoted_metrics?: {
            /** Number of users who made it through 0% of the video. */
            playback_0_count?: number;
            /** Number of users who made it through 25% of the video. */
            playback_25_count?: number;
            /** Number of users who made it through 50% of the video. */
            playback_50_count?: number;
            /** Number of users who made it through 75% of the video. */
            playback_75_count?: number;
            /** Number of users who made it through 100% of the video. */
            playback_100_count?: number;
            /** Number of times this video has been viewed. */
            view_count?: number;
        };
    };
    export type AnimatedGif = Schemas.CommonMediaFields & {
        type?: "animated_gif";
        preview_image_url?: string;
    };
    /** The Media Key identifier for this attachment. */
    export type MediaKey = string;
    /** Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country). */
    export interface TweetWithheld {
        /** Indicates if the content is being withheld for on the basis of copyright infringement. */
        copyright: boolean;
        /** Provides a list of countries where this content is not available. */
        country_codes: Schemas.CountryCode[];
        /** Indicates whether the content being withheld is the `tweet` or a `user`. */
        scope?: "tweet" | "user";
    }
    /** Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country). */
    export interface UserWithheld {
        /** Provides a list of countries where this content is not available. */
        country_codes: Schemas.CountryCode[];
        /** Indicates that the content being withheld is a `user`. */
        scope?: "user";
    }
    export type CountryCode = string;
    export interface ProblemFields {
        title: string;
        detail: string;
    }
    export type GenericProblem = Schemas.ProblemFields & {
        type?: "about:blank";
        status: number;
    };
    export type InvalidRequestProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/invalid-request";
        errors?: {
            parameters?: {
                [key: string]: string[];
            };
            message?: string;
        }[];
    };
    export type ResourceNotFoundProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/resource-not-found";
        parameter: string;
        /** Value will match the schema of the field. */
        value: string;
        resource_type: "user" | "tweet" | "media";
    };
    export type ResourceUnauthorizedProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/not-authorized-for-resource";
        value: string;
        parameter: string;
        section: "data" | "includes";
        resource_type: "tweet" | "user" | "media";
    };
    export type FieldUnauthorizedProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/not-authorized-for-field";
        section: "data" | "includes";
        resource_type: "tweet" | "media";
        field: string;
    };
    export type ClientForbiddenProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/client-forbidden";
        reason?: "official-client-forbidden" | "client-not-enrolled";
        registration_url?: string;
    };
    export type DisallowedResourceProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/disallowed-resource";
        resource_id: string;
        resource_type: "tweet" | "media";
        section: "data" | "includes";
    };
    export type UnsupportedAuthenticationProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/unsupported-authentication";
    };
    export type UsageCapExceededProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/usage-capped";
        period?: "Daily" | "Monthly";
        scope?: "Account" | "Product";
    };
    export type ConnectionExceptionProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/streaming-connection";
        connection_issue?: "TooManyConnections" | "ProvisioningSubscription";
    };
    export type ClientDisconnectedProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/client-disconnected";
    };
    export type OperationalDisconnectProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/operational-disconnect";
        disconnect_type?: "OperationalDisconnect" | "UpstreamOperationalDisconnect" | "ForceDisconnect" | "UpstreamUncleanDisconnect" | "SlowReader" | "InternalError" | "PackageUpgraded" | "PackageDowngraded" | "ClientApplicationStateDegraded";
    };
    export type RulesCapProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/rule-cap";
    };
    export type InvalidRuleProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/invalid-rules";
    };
    export type DuplicateRuleProblem = Schemas.ProblemFields & {
        type?: "https://api.twitter.com/2/problems/duplicate-rules";
    };
    export type Problem = Schemas.GenericProblem | Schemas.InvalidRequestProblem | Schemas.ClientForbiddenProblem | Schemas.ResourceNotFoundProblem | Schemas.ResourceUnauthorizedProblem | Schemas.FieldUnauthorizedProblem | Schemas.DisallowedResourceProblem | Schemas.UnsupportedAuthenticationProblem | Schemas.UsageCapExceededProblem | Schemas.ConnectionExceptionProblem | Schemas.ClientDisconnectedProblem | Schemas.OperationalDisconnectProblem | Schemas.RulesCapProblem | Schemas.InvalidRuleProblem | Schemas.DuplicateRuleProblem;
    export interface TweetSearchResponse {
        data?: Schemas.Tweet[];
        includes?: Schemas.Expansions;
        errors?: Schemas.Problem[];
        meta?: {
            /** Most recent Tweet Id returned by search query */
            newest_id?: string;
            /** Oldest Tweet Id returned by search query */
            oldest_id?: string;
            /** This value is used to get the next 'page' of results by providing it to the next_token parameter. */
            next_token?: string;
            /** Number of search query results */
            result_count?: number;
        };
    }
    export type StreamingTweet = Schemas.SingleTweetLookupResponse | {
        errors: Schemas.Problem[];
    };
    export type FilteredStreamingTweet = {
        data: Schemas.Tweet;
        /** The list of rules which matched the tweet */
        matching_rules: {
            id: Schemas.RuleId;
            /** The user-supplied tag assigned to the rule which matched */
            tag?: string;
        }[];
        includes?: Schemas.Expansions;
    } | {
        errors: Schemas.Problem[];
    };
    /** Unique identifier of this rule. */
    export type RuleId = string;
    export interface Rule {
        value: Schemas.RuleValue;
        tag?: Schemas.RuleTag;
        id?: Schemas.RuleId;
    }
    export interface RuleNoId {
        value: Schemas.RuleValue;
        tag?: Schemas.RuleTag;
    }
    /** A tag meant for the labeling of user provided rules. */
    export type RuleTag = string;
    /** The filterlang value of the rule. */
    export type RuleValue = string;
    export interface RulesResponseMetadata {
        sent: string;
        summary?: Schemas.RulesRequestSummary;
    }
    export type RulesRequestSummary = {
        created: number;
        not_created: number;
    } | {
        deleted: number;
        not_deleted: number;
    };
    export type AddOrDeleteRulesRequest = Schemas.AddRulesRequest | Schemas.DeleteRulesRequest;
    export type AddOrDeleteRulesResponse = Schemas.AddRulesResponse | Schemas.DeleteRulesResponse;
    export interface AddRulesRequest {
        add: Schemas.RuleNoId[];
    }
    export interface AddRulesResponse {
        data: Schemas.Rule[];
        meta: Schemas.RulesResponseMetadata;
    }
    export interface DeleteRulesRequest {
        ids?: Schemas.RuleId[];
        values?: Schemas.RuleValue[];
    }
    export interface DeleteRulesResponse {
        meta: Schemas.RulesResponseMetadata;
    }
    export interface UsersFollowersLookupResponse {
        data?: Schemas.User[];
        includes?: Schemas.Expansions;
        errors?: Schemas.Problem[];
        meta?: {
            /** The previous token */
            previous_token?: string;
            /** The next token */
            next_token?: string;
            /** The number of user results returned in this response */
            result_count?: number;
        };
    }
    export interface UsersFollowingLookupResponse {
        data?: Schemas.User[];
        includes?: Schemas.Expansions;
        errors?: Schemas.Problem[];
        meta?: {
            /** The previous token */
            previous_token?: string;
            /** The next token */
            next_token?: string;
            /** The number of user results returned in this response */
            result_count?: number;
        };
    }
    export interface UsersFollowingCreateResponse {
        data?: {
            following?: boolean;
            pending_follow?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface UsersFollowingDeleteResponse {
        data?: {
            following?: boolean;
        };
        errors?: Schemas.Problem[];
    }
}
export namespace Responses {
    /** The request has failed. */
    export namespace HttpErrorResponse {
        export interface Content {
            "application/json": Schemas.Error;
            "application/problem+json": Schemas.Problem;
        }
    }
}
export namespace Parameters {
    /** A comma separated list of fields to expand. */
    export type TweetExpansionsParameter = ("author_id" | "referenced_tweets.id" | "in_reply_to_user_id" | "geo.place_id" | "attachments.media_keys" | "attachments.poll_ids" | "entities.mentions.username" | "referenced_tweets.id.author_id")[];
    /** A comma separated list of fields to expand. */
    export type UserExpansionsParameter = ("pinned_tweet_id")[];
    /** A comma separated list of Tweet fields to display. */
    export type TweetFieldsParameter = ("id" | "created_at" | "text" | "author_id" | "in_reply_to_user_id" | "referenced_tweets" | "attachments" | "withheld" | "geo" | "entities" | "public_metrics" | "possibly_sensitive" | "source" | "lang" | "context_annotations" | "non_public_metrics" | "promoted_metrics" | "organic_metrics" | "conversation_id" | "reply_settings")[];
    /** A comma separated list of User fields to display. */
    export type UserFieldsParameter = ("id" | "created_at" | "name" | "username" | "protected" | "verified" | "withheld" | "profile_image_url" | "location" | "url" | "description" | "entities" | "pinned_tweet_id" | "public_metrics")[];
    /** A comma separated list of Media fields to display. */
    export type MediaFieldsParameter = ("media_key" | "duration_ms" | "height" | "preview_image_url" | "type" | "url" | "width" | "public_metrics" | "non_public_metrics" | "organic_metrics" | "promoted_metrics")[];
    /** A comma separated list of Place fields to display. */
    export type PlaceFieldsParameter = ("id" | "name" | "country_code" | "place_type" | "full_name" | "country" | "contained_within" | "geo")[];
    /** A comma separated list of Poll fields to display. */
    export type PollFieldsParameter = ("id" | "options" | "voting_status" | "end_datetime" | "duration_minutes")[];
    /** The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. */
    export type SinceIdRequestParameter = Schemas.TweetID;
    /** The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. */
    export type UntilIdRequestParameter = Schemas.TweetID;
    /** This parameter is used to get the next 'page' of results. */
    export type PaginationTokenRequestParameter = string;
    /** The maximum number of results */
    export type MaxResultsRequestParameter = number;
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the mentions will be provided. The since_id parameter takes precedence if it is also specified. */
    export type StartTimeRequestParameter = string;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. */
    export type EndTimeRequestParameter = string;
    /** The set of entities to exclude (e.g. 'replies' or 'retweets') */
    export type TweetTypeExcludesRequestParameter = ("replies" | "retweets")[];
}
export interface Parameter$findUsersById {
    /** Required. A list of User IDs, comma-separated. You can specify up to 100 IDs. */
    ids: Schemas.UserID[];
    /** A comma separated list of fields to expand. */
    expansions: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
}
export interface Response$findUsersById$Status$200 {
    "application/json": Schemas.UserLookupResponse;
}
export type Response$findUsersById$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$findUserById {
    /** Required. A User ID. */
    id: Schemas.UserID;
    /** A comma separated list of fields to expand. */
    expansions: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
}
export interface Response$findUserById$Status$200 {
    "application/json": Schemas.SingleUserLookupResponse;
}
export type Response$findUserById$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$findUsersByUsername {
    /** Required . A list of usernames, comma-separated. You can specify up to 100 usernames. */
    usernames: Schemas.UserName[];
    /** A comma separated list of fields to expand. */
    expansions: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
}
export interface Response$findUsersByUsername$Status$200 {
    "application/json": Schemas.UserLookupResponse;
}
export type Response$findUsersByUsername$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$findUserByUsername {
    /** Required. A username. */
    username: Schemas.UserName;
    /** A comma separated list of fields to expand. */
    expansions: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
}
export interface Response$findUserByUsername$Status$200 {
    "application/json": Schemas.SingleUserLookupResponse;
}
export type Response$findUserByUsername$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$usersIdFollowers {
    /** The ID of the user for whom to return results */
    id: Schemas.UserID;
    /** The maximum number of results */
    max_results?: number;
    /** This value is populated by passing the 'next_token' or 'previous_token' returned in a request to paginate through results. */
    pagination_token?: string;
}
export interface Response$usersIdFollowers$Status$200 {
    "application/json": Schemas.UsersFollowersLookupResponse;
}
export type Response$usersIdFollowers$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$usersIdFollowing {
    /** The ID of the user for whom to return results */
    id: Schemas.UserID;
    /** The maximum number of results */
    max_results?: number;
    /** This value is populated by passing the 'next_token' or 'previous_token' returned in a request to paginate through results. */
    pagination_token?: string;
}
export interface Response$usersIdFollowing$Status$200 {
    "application/json": Schemas.UsersFollowingLookupResponse;
}
export type Response$usersIdFollowing$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$usersIdFollow {
    /** The ID of the user that is requesting to follow the target user */
    id: Schemas.UserID;
}
export interface RequestBody$usersIdFollow {
    "application/json": {
        target_user_id: string;
    };
}
export interface Response$usersIdFollow$Status$200 {
    "application/json": Schemas.UsersFollowingCreateResponse;
}
export type Response$usersIdFollow$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$usersIdUnfollow {
    /** The ID of the user that is requesting to unfollow the target user */
    source_user_id: Schemas.UserID;
    /** The ID of the user that the source user is requesting to unfollow */
    target_user_id: Schemas.UserID;
}
export interface Response$usersIdUnfollow$Status$200 {
    "application/json": Schemas.UsersFollowingDeleteResponse;
}
export type Response$usersIdUnfollow$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$findTweetsById {
    /** A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. */
    ids: Schemas.TweetID[];
    /** A comma separated list of fields to expand. */
    expansions: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields": Parameters.MediaFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields": Parameters.PlaceFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields": Parameters.PollFieldsParameter;
}
export interface Response$findTweetsById$Status$200 {
    "application/json": Schemas.TweetLookupResponse;
}
export type Response$findTweetsById$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$findTweetById {
    /** A single Tweet ID. */
    id: Schemas.TweetID;
    /** A comma separated list of fields to expand. */
    expansions: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields": Parameters.MediaFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields": Parameters.PlaceFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields": Parameters.PollFieldsParameter;
}
export interface Response$findTweetById$Status$200 {
    "application/json": Schemas.SingleTweetLookupResponse;
}
export type Response$findTweetById$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$hideReplyById {
    /** The ID of the reply that you want to hide or unhide. */
    id: Schemas.TweetID;
}
export interface RequestBody$hideReplyById {
    "application/json": {
        hidden?: boolean;
    };
}
export interface Response$hideReplyById$Status$200 {
    "application/json": {
        data?: {
            hidden?: boolean;
        };
    };
}
export type Response$hideReplyById$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$tweetsRecentSearch {
    /** One query/rule/filter for matching Tweets. Up to 512 characters. */
    query: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). */
    end_time?: string;
    /** Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. */
    since_id?: Schemas.TweetID;
    /** Returns results with a Tweet ID less than (that is, older than) the specified ID. */
    until_id?: Schemas.TweetID;
    /** The maximum number of search results to be returned by a request. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    next_token?: string;
    /** A comma separated list of fields to expand. */
    expansions: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields": Parameters.MediaFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields": Parameters.PlaceFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields": Parameters.PollFieldsParameter;
}
export interface Response$tweetsRecentSearch$Status$200 {
    "application/json": Schemas.TweetSearchResponse;
}
export type Response$tweetsRecentSearch$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$tweetsFullarchiveSearch {
    /** One query/rule/filter for matching Tweets. Up to 1024 characters. */
    query: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). */
    end_time?: string;
    /** Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. */
    since_id?: Schemas.TweetID;
    /** Returns results with a Tweet ID less than (that is, older than) the specified ID. */
    until_id?: Schemas.TweetID;
    /** The maximum number of search results to be returned by a request. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    next_token?: string;
    /** A comma separated list of fields to expand. */
    expansions: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields": Parameters.MediaFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields": Parameters.PlaceFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields": Parameters.PollFieldsParameter;
}
export interface Response$tweetsFullarchiveSearch$Status$200 {
    "application/json": {
        data?: Schemas.Tweet[];
        includes?: Schemas.Expansions;
        errors?: Schemas.Problem[];
        meta?: {
            /** Most recent Tweet Id returned by search query */
            newest_id?: string;
            /** Oldest Tweet Id returned by search query */
            oldest_id?: string;
            /** This value is used to get the next 'page' of results by providing it to the next_token parameter. */
            next_token?: string;
            /** Number of search query results */
            result_count?: number;
        };
    };
}
export type Response$tweetsFullarchiveSearch$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$searchStream {
    /** A comma separated list of fields to expand. */
    expansions: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields": Parameters.MediaFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields": Parameters.PlaceFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields": Parameters.PollFieldsParameter;
}
export interface Response$searchStream$Status$200 {
    "application/json": Schemas.FilteredStreamingTweet;
}
export type Response$searchStream$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$getRules {
    /** A comma-separated list of Rule IDs. */
    ids?: Schemas.RuleId[];
}
export interface Response$getRules$Status$200 {
    "application/json": {
        data: Schemas.Rule[];
        meta: Schemas.RulesResponseMetadata;
    };
}
export type Response$getRules$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$addOrDeleteRules {
    /** Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. */
    dry_run?: boolean;
}
export interface RequestBody$addOrDeleteRules {
    "application/json": Schemas.AddOrDeleteRulesRequest;
}
export interface Response$addOrDeleteRules$Status$200 {
    "application/json": Schemas.AddOrDeleteRulesResponse;
}
export type Response$addOrDeleteRules$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$sampleStream {
    /** A comma separated list of fields to expand. */
    expansions: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields": Parameters.MediaFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields": Parameters.PlaceFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields": Parameters.PollFieldsParameter;
}
export interface Response$sampleStream$Status$200 {
    "application/json": Schemas.StreamingTweet;
}
export type Response$sampleStream$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$getOpenApiSpec {
}
export interface Response$getOpenApiSpec$Status$200 {
    "application/json": {};
}
export interface Parameter$usersIdTweets {
    /** The ID of the User to list Tweets of */
    id: Schemas.UserID;
    /** The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. */
    since_id: Parameters.SinceIdRequestParameter;
    /** The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. */
    until_id: Parameters.UntilIdRequestParameter;
    /** The maximum number of results */
    max_results: Parameters.MaxResultsRequestParameter;
    /** The set of entities to exclude (e.g. 'replies' or 'retweets') */
    exclude: Parameters.TweetTypeExcludesRequestParameter;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token: Parameters.PaginationTokenRequestParameter;
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the mentions will be provided. The since_id parameter takes precedence if it is also specified. */
    start_time: Parameters.StartTimeRequestParameter;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. */
    end_time: Parameters.EndTimeRequestParameter;
    /** A comma separated list of fields to expand. */
    expansions: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields": Parameters.MediaFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields": Parameters.PlaceFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields": Parameters.PollFieldsParameter;
}
export interface Response$usersIdTweets$Status$200 {
    "application/json": Schemas.TweetLookupResponse;
}
export type Response$usersIdTweets$Status$default = Responses.HttpErrorResponse.Content;
export interface Parameter$usersIdMentions {
    /** The ID of the User to list mentions of */
    id: Schemas.UserID;
    /** The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. */
    since_id: Parameters.SinceIdRequestParameter;
    /** The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. */
    until_id: Parameters.UntilIdRequestParameter;
    /** The maximum number of results */
    max_results: Parameters.MaxResultsRequestParameter;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token: Parameters.PaginationTokenRequestParameter;
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the mentions will be provided. The since_id parameter takes precedence if it is also specified. */
    start_time: Parameters.StartTimeRequestParameter;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. */
    end_time: Parameters.EndTimeRequestParameter;
    /** A comma separated list of fields to expand. */
    expansions: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields": Parameters.TweetFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields": Parameters.UserFieldsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields": Parameters.MediaFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields": Parameters.PlaceFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields": Parameters.PollFieldsParameter;
}
export interface Response$usersIdMentions$Status$200 {
    "application/json": Schemas.TweetLookupResponse;
}
export type Response$usersIdMentions$Status$default = Responses.HttpErrorResponse.Content;
export type ResponseContentType$findUsersById = keyof Response$findUsersById$Status$200;
export interface Params$findUsersById {
    parameter: Parameter$findUsersById;
}
export type ResponseContentType$findUserById = keyof Response$findUserById$Status$200;
export interface Params$findUserById {
    parameter: Parameter$findUserById;
}
export type ResponseContentType$findUsersByUsername = keyof Response$findUsersByUsername$Status$200;
export interface Params$findUsersByUsername {
    parameter: Parameter$findUsersByUsername;
}
export type ResponseContentType$findUserByUsername = keyof Response$findUserByUsername$Status$200;
export interface Params$findUserByUsername {
    parameter: Parameter$findUserByUsername;
}
export type ResponseContentType$usersIdFollowers = keyof Response$usersIdFollowers$Status$200;
export interface Params$usersIdFollowers {
    parameter: Parameter$usersIdFollowers;
}
export type ResponseContentType$usersIdFollowing = keyof Response$usersIdFollowing$Status$200;
export interface Params$usersIdFollowing {
    parameter: Parameter$usersIdFollowing;
}
export type RequestContentType$usersIdFollow = keyof RequestBody$usersIdFollow;
export type ResponseContentType$usersIdFollow = keyof Response$usersIdFollow$Status$200;
export interface Params$usersIdFollow {
    parameter: Parameter$usersIdFollow;
    requestBody: RequestBody$usersIdFollow["application/json"];
}
export type ResponseContentType$usersIdUnfollow = keyof Response$usersIdUnfollow$Status$200;
export interface Params$usersIdUnfollow {
    parameter: Parameter$usersIdUnfollow;
}
export type ResponseContentType$findTweetsById = keyof Response$findTweetsById$Status$200;
export interface Params$findTweetsById {
    parameter: Parameter$findTweetsById;
}
export type ResponseContentType$findTweetById = keyof Response$findTweetById$Status$200;
export interface Params$findTweetById {
    parameter: Parameter$findTweetById;
}
export type RequestContentType$hideReplyById = keyof RequestBody$hideReplyById;
export type ResponseContentType$hideReplyById = keyof Response$hideReplyById$Status$200;
export interface Params$hideReplyById {
    parameter: Parameter$hideReplyById;
    requestBody: RequestBody$hideReplyById["application/json"];
}
export type ResponseContentType$tweetsRecentSearch = keyof Response$tweetsRecentSearch$Status$200;
export interface Params$tweetsRecentSearch {
    parameter: Parameter$tweetsRecentSearch;
}
export type ResponseContentType$tweetsFullarchiveSearch = keyof Response$tweetsFullarchiveSearch$Status$200;
export interface Params$tweetsFullarchiveSearch {
    parameter: Parameter$tweetsFullarchiveSearch;
}
export type ResponseContentType$searchStream = keyof Response$searchStream$Status$200;
export interface Params$searchStream {
    parameter: Parameter$searchStream;
}
export type ResponseContentType$getRules = keyof Response$getRules$Status$200;
export interface Params$getRules {
    parameter: Parameter$getRules;
}
export type RequestContentType$addOrDeleteRules = keyof RequestBody$addOrDeleteRules;
export type ResponseContentType$addOrDeleteRules = keyof Response$addOrDeleteRules$Status$200;
export interface Params$addOrDeleteRules {
    parameter: Parameter$addOrDeleteRules;
    requestBody: RequestBody$addOrDeleteRules["application/json"];
}
export type ResponseContentType$sampleStream = keyof Response$sampleStream$Status$200;
export interface Params$sampleStream {
    parameter: Parameter$sampleStream;
}
export type ResponseContentType$getOpenApiSpec = keyof Response$getOpenApiSpec$Status$200;
export type ResponseContentType$usersIdTweets = keyof Response$usersIdTweets$Status$200;
export interface Params$usersIdTweets {
    parameter: Parameter$usersIdTweets;
}
export type ResponseContentType$usersIdMentions = keyof Response$usersIdMentions$Status$200;
export interface Params$usersIdMentions {
    parameter: Parameter$usersIdMentions;
}
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$findUsersById$Status$200 | Response$findUserById$Status$200 | Response$findUsersByUsername$Status$200 | Response$findUserByUsername$Status$200 | Response$usersIdFollowers$Status$200 | Response$usersIdFollowing$Status$200 | Response$usersIdFollow$Status$200 | Response$usersIdUnfollow$Status$200 | Response$findTweetsById$Status$200 | Response$findTweetById$Status$200 | Response$hideReplyById$Status$200 | Response$tweetsRecentSearch$Status$200 | Response$tweetsFullarchiveSearch$Status$200 | Response$searchStream$Status$200 | Response$getRules$Status$200 | Response$addOrDeleteRules$Status$200 | Response$sampleStream$Status$200 | Response$getOpenApiSpec$Status$200 | Response$usersIdTweets$Status$200 | Response$usersIdMentions$Status$200;
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    constructor(private apiClient: ApiClient<RequestOption>, private baseUrl: string) { }
    /**
     * Return details for the specified users
     * This endpoint returns information about users. Specify users by their ID.
     */
    public async findUsersById(params: Params$findUsersById, option?: RequestOption): Promise<Response$findUsersById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ids: { value: params.parameter.ids, style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Return details for the specified users
     * This endpoint returns information about a user. Specify user by ID.
     */
    public async findUserById(params: Params$findUserById, option?: RequestOption): Promise<Response$findUserById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Return details for the specified users
     * This endpoint returns information about users. Specify users by their username.
     */
    public async findUsersByUsername(params: Params$findUsersByUsername, option?: RequestOption): Promise<Response$findUsersByUsername$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/by`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            usernames: { value: params.parameter.usernames, style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Return details for the specified users
     * This endpoint returns information about a user. Specify user by username.
     */
    public async findUserByUsername(params: Params$findUserByUsername, option?: RequestOption): Promise<Response$findUserByUsername$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/by/username/${params.parameter.username}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns user objects that follow the provided user ID
     * Returns a list of users that follow the provided user ID
     */
    public async usersIdFollowers(params: Params$usersIdFollowers, option?: RequestOption): Promise<Response$usersIdFollowers$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/followers`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, explode: false },
            pagination_token: { value: params.parameter.pagination_token, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns user objects that are being followed by the provided user ID
     * Returns a list of users that are being followed by the provided user ID
     */
    public async usersIdFollowing(params: Params$usersIdFollowing, option?: RequestOption): Promise<Response$usersIdFollowing$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/following`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, explode: false },
            pagination_token: { value: params.parameter.pagination_token, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Causes the user(in the path) to follow the target user, defined by user ID
     * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
     */
    public async usersIdFollow(params: Params$usersIdFollow, option?: RequestOption): Promise<Response$usersIdFollow$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/following`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Causes the source user to unfollow the target user, defined by user ID
     * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
     */
    public async usersIdUnfollow(params: Params$usersIdUnfollow, option?: RequestOption): Promise<Response$usersIdUnfollow$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.source_user_id}/following/${params.parameter.target_user_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Returns hydrated Tweet objects
     * Returns a variety of information about the Tweet specified by the requested ID
     */
    public async findTweetsById(params: Params$findTweetsById, option?: RequestOption): Promise<Response$findTweetsById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ids: { value: params.parameter.ids, style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns hydrated Tweet objects
     * Returns a variety of information about the Tweet specified by the requested ID
     */
    public async findTweetById(params: Params$findTweetById, option?: RequestOption): Promise<Response$findTweetById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Hides or unhides a reply to an owned conversation.
     * Tweet ID in the path is that of the reply to hide or unhide.
     */
    public async hideReplyById(params: Params$hideReplyById, option?: RequestOption): Promise<Response$hideReplyById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/${params.parameter.id}/hidden`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * Returns Tweets from the last 7 days that match a search query.
     */
    public async tweetsRecentSearch(params: Params$tweetsRecentSearch, option?: RequestOption): Promise<Response$tweetsRecentSearch$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/recent`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            query: { value: params.parameter.query, explode: false },
            start_time: { value: params.parameter.start_time, explode: false },
            end_time: { value: params.parameter.end_time, explode: false },
            since_id: { value: params.parameter.since_id, explode: false },
            until_id: { value: params.parameter.until_id, explode: false },
            max_results: { value: params.parameter.max_results, explode: false },
            next_token: { value: params.parameter.next_token, explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns Tweets that match a search query.
     * Returns Tweets that match a search query.
     */
    public async tweetsFullarchiveSearch(params: Params$tweetsFullarchiveSearch, option?: RequestOption): Promise<Response$tweetsFullarchiveSearch$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/all`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            query: { value: params.parameter.query, explode: false },
            start_time: { value: params.parameter.start_time, explode: false },
            end_time: { value: params.parameter.end_time, explode: false },
            since_id: { value: params.parameter.since_id, explode: false },
            until_id: { value: params.parameter.until_id, explode: false },
            max_results: { value: params.parameter.max_results, explode: false },
            next_token: { value: params.parameter.next_token, explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Streams tweets matching a user's active rule set.
     * Streams tweets matching a user's active rule set.
     */
    public async searchStream(params: Params$searchStream, option?: RequestOption): Promise<Response$searchStream$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/stream`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns rules from a user's active rule set.
     * Returns rules from a user's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     */
    public async getRules(params: Params$getRules, option?: RequestOption): Promise<Response$getRules$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/stream/rules`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ids: { value: params.parameter.ids, explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Add or delete rules from a user's active rule set.
     * Add or delete rules from a user's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     */
    public async addOrDeleteRules(params: Params$addOrDeleteRules, option?: RequestOption): Promise<Response$addOrDeleteRules$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/stream/rules`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            dry_run: { value: params.parameter.dry_run, explode: false }
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, queryParameters, option);
    }
    /**
     * Streams a deterministic 1% of public tweets.
     * Streams a deterministic 1% of public tweets.
     */
    public async sampleStream(params: Params$sampleStream, option?: RequestOption): Promise<Response$sampleStream$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/sample/stream`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns the open api spec document.
     * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     */
    public async getOpenApiSpec(option?: RequestOption): Promise<Response$getOpenApiSpec$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/openapi.json`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Returns Tweet objects authored by the provided User ID
     * Returns a list of Tweets authored by the provided User ID
     */
    public async usersIdTweets(params: Params$usersIdTweets, option?: RequestOption): Promise<Response$usersIdTweets$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/tweets`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            since_id: { value: params.parameter.since_id, explode: false },
            until_id: { value: params.parameter.until_id, explode: false },
            max_results: { value: params.parameter.max_results, explode: false },
            exclude: { value: params.parameter.exclude, explode: false },
            pagination_token: { value: params.parameter.pagination_token, explode: false },
            start_time: { value: params.parameter.start_time, explode: false },
            end_time: { value: params.parameter.end_time, explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns Tweet objects that mention the username associated to the provided User ID
     * Returns Tweet objects that mention username associated to the provided User ID
     */
    public async usersIdMentions(params: Params$usersIdMentions, option?: RequestOption): Promise<Response$usersIdMentions$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/mentions`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            since_id: { value: params.parameter.since_id, explode: false },
            until_id: { value: params.parameter.until_id, explode: false },
            max_results: { value: params.parameter.max_results, explode: false },
            pagination_token: { value: params.parameter.pagination_token, explode: false },
            start_time: { value: params.parameter.start_time, explode: false },
            end_time: { value: params.parameter.end_time, explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
}
