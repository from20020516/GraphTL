// 
// Generated by @himenon/openapi-typescript-code-generator v0.19.1
// 
// OpenApi : 3.0.0
// 
// License  : Twitter Developer Agreement and Policy
// Url      : https://developer.twitter.com/en/developer-terms/agreement-and-policy.html
// 


export namespace Schemas {
    export type AddOrDeleteRulesRequest = Schemas.AddRulesRequest | Schemas.DeleteRulesRequest;
    /** A response from modifying user-specified stream filtering rules. */
    export interface AddOrDeleteRulesResponse {
        /** All user-specified stream filtering rules that were created. */
        data?: Schemas.Rule[];
        errors?: Schemas.Problem[];
        meta: Schemas.RulesResponseMetadata;
    }
    /** A request to add a user-specified stream filtering rule. */
    export interface AddRulesRequest {
        add: Schemas.RuleNoId[];
    }
    /** The sum of results returned in this response. */
    export type Aggregate = number;
    export type AnimatedGif = Schemas.Media & {
        preview_image_url?: string;
        variants?: Schemas.Variants;
    };
    export interface BlockUserMutationResponse {
        data?: {
            blocking?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface BlockUserRequest {
        target_user_id: Schemas.UserId;
    }
    export interface BookmarkAddRequest {
        tweet_id: Schemas.TweetId;
    }
    export interface BookmarkMutationResponse {
        data?: {
            bookmarked?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export type CashtagEntity = Schemas.EntityIndicesInclusiveExclusive & Schemas.CashtagFields;
    /** Represent the portion of text recognized as a Cashtag, and its start and end position within the text. */
    export interface CashtagFields {
        tag: string;
    }
    export type ClientDisconnectedProblem = Schemas.Problem;
    export type ClientForbiddenProblem = Schemas.Problem & {
        reason?: "official-client-forbidden" | "client-not-enrolled";
        registration_url?: string;
    };
    export interface ComplianceJob {
        created_at: Schemas.CreatedAt;
        download_expires_at: Schemas.DownloadExpiration;
        download_url: Schemas.DownloadUrl;
        id: Schemas.JobId;
        name?: Schemas.ComplianceJobName;
        status: Schemas.ComplianceJobStatus;
        type: Schemas.ComplianceJobType;
        upload_expires_at: Schemas.UploadExpiration;
        upload_url: Schemas.UploadUrl;
    }
    /** User-provided name for a compliance job. */
    export type ComplianceJobName = string;
    /** Status of a compliance job. */
    export type ComplianceJobStatus = "created" | "in_progress" | "failed" | "complete" | "expired";
    /** Type of compliance job to list. */
    export type ComplianceJobType = "tweets" | "users";
    export type ConflictProblem = Schemas.Problem;
    export type ConnectionExceptionProblem = Schemas.Problem & {
        connection_issue?: "TooManyConnections" | "ProvisioningSubscription" | "RuleConfigurationIssue" | "RulesInvalidIssue";
    };
    /** Annotation inferred from the Tweet text. */
    export interface ContextAnnotation {
        domain: Schemas.ContextAnnotationDomainFields;
        entity: Schemas.ContextAnnotationEntityFields;
    }
    /** Represents the data for the context annotation domain. */
    export interface ContextAnnotationDomainFields {
        /** Description of the context annotation domain. */
        description?: string;
        /** The unique id for a context annotation domain. */
        id: string;
        /** Name of the context annotation domain. */
        name?: string;
    }
    /** Represents the data for the context annotation entity. */
    export interface ContextAnnotationEntityFields {
        /** Description of the context annotation entity. */
        description?: string;
        /** The unique id for a context annotation entity. */
        id: string;
        /** Name of the context annotation entity. */
        name?: string;
    }
    /** A two-letter ISO 3166-1 alpha-2 country code. */
    export type CountryCode = string;
    /** A request to create a new batch compliance job. */
    export interface CreateComplianceJobRequest {
        name?: Schemas.ComplianceJobName;
        /** If true, this endpoint will return a pre-signed URL with resumable uploads enabled. */
        resumable?: boolean;
        /** Type of compliance job to list. */
        type: "tweets" | "users";
    }
    export interface CreateComplianceJobResponse {
        data?: Schemas.ComplianceJob;
        errors?: Schemas.Problem[];
    }
    /** Creation time of the compliance job. */
    export type CreatedAt = string;
    /** A response from deleting user-specified stream filtering rules. */
    export interface DeleteRulesRequest {
        /** IDs and values of all deleted user-specified stream filtering rules. */
        delete: {
            /** IDs of all deleted user-specified stream filtering rules. */
            ids?: Schemas.RuleId[];
            /** Values of all deleted user-specified stream filtering rules. */
            values?: Schemas.RuleValue[];
        };
    }
    export type DisallowedResourceProblem = Schemas.Problem & {
        resource_id: string;
        resource_type: "user" | "tweet" | "media" | "list" | "space";
        section: "data" | "includes";
    };
    /** Expiration time of the download URL. */
    export type DownloadExpiration = string;
    /** URL from which the user will retrieve their compliance results. */
    export type DownloadUrl = string;
    export type DuplicateRuleProblem = Schemas.Problem & {
        id?: string;
        value?: string;
    };
    /** The end time of the bucket. */
    export type End = string;
    /** Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive. */
    export interface EntityIndicesInclusiveExclusive {
        /** Index (zero-based) at which position this entity ends.  The index is exclusive. */
        end: number;
        /** Index (zero-based) at which position this entity starts.  The index is inclusive. */
        start: number;
    }
    /** Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is inclusive. */
    export interface EntityIndicesInclusiveInclusive {
        /** Index (zero-based) at which position this entity ends.  The index is inclusive. */
        end: number;
        /** Index (zero-based) at which position this entity starts.  The index is inclusive. */
        start: number;
    }
    export interface Error {
        code: number;
        message: string;
    }
    export interface Expansions {
        media?: Schemas.Media[];
        places?: Schemas.Place[];
        polls?: Schemas.Poll[];
        topics?: Schemas.Topic[];
        tweets?: Schemas.Tweet[];
        users?: Schemas.User[];
    }
    export type FieldUnauthorizedProblem = Schemas.Problem & {
        field: string;
        resource_type: "user" | "tweet" | "media" | "list" | "space";
        section: "data" | "includes";
    };
    /** A Tweet or error that can be returned by the streaming Tweet API. The values returned with a successful streamed Tweet includes the user provided rules that the Tweet matched. */
    export interface FilteredStreamingTweetResponse {
        data?: Schemas.Tweet;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        /** The list of rules which matched the Tweet */
        matching_rules?: {
            id: Schemas.RuleId;
            tag?: Schemas.RuleTag;
        }[];
    }
    export interface FullTextEntities {
        annotations?: (Schemas.EntityIndicesInclusiveInclusive & {
            /** Text used to determine annotation. */
            normalized_text?: string;
            /** Confidence factor for annotation type. */
            probability?: number;
            /** Annotation type. */
            type?: string;
        })[];
        cashtags?: Schemas.CashtagEntity[];
        hashtags?: Schemas.HashtagEntity[];
        mentions?: Schemas.MentionEntity[];
        urls?: Schemas.UrlEntity[];
    }
    export type GenericProblem = Schemas.Problem;
    export interface Geo {
        bbox: number[];
        geometry?: Schemas.Point;
        properties: {};
        type: "Feature";
    }
    export interface Get2ComplianceJobsIdResponse {
        data?: Schemas.ComplianceJob;
        errors?: Schemas.Problem[];
    }
    export interface Get2ComplianceJobsResponse {
        data?: Schemas.ComplianceJob[];
        errors?: Schemas.Problem[];
        meta?: {
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2ListsIdFollowersResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2ListsIdMembersResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2ListsIdResponse {
        data?: Schemas.List;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2ListsIdTweetsResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2SpacesByCreatorIdsResponse {
        data?: Schemas.Space[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2SpacesIdBuyersResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2SpacesIdResponse {
        data?: Schemas.Space;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2SpacesIdTweetsResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2SpacesResponse {
        data?: Schemas.Space[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2SpacesSearchResponse {
        data?: Schemas.Space[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2TweetsCountsAllResponse {
        data?: Schemas.SearchCount[];
        errors?: Schemas.Problem[];
        meta?: {
            newest_id?: Schemas.NewestId;
            next_token?: Schemas.NextToken;
            oldest_id?: Schemas.OldestId;
            total_tweet_count?: Schemas.Aggregate;
        };
    }
    export interface Get2TweetsCountsRecentResponse {
        data?: Schemas.SearchCount[];
        errors?: Schemas.Problem[];
        meta?: {
            newest_id?: Schemas.NewestId;
            next_token?: Schemas.NextToken;
            oldest_id?: Schemas.OldestId;
            total_tweet_count?: Schemas.Aggregate;
        };
    }
    export interface Get2TweetsFirehoseStreamResponse {
        data?: Schemas.Tweet;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2TweetsIdLikingUsersResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2TweetsIdQuoteTweetsResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2TweetsIdResponse {
        data?: Schemas.Tweet;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2TweetsIdRetweetedByResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2TweetsResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2TweetsSample10StreamResponse {
        data?: Schemas.Tweet;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2TweetsSampleStreamResponse {
        data?: Schemas.Tweet;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2TweetsSearchAllResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            newest_id?: Schemas.NewestId;
            next_token?: Schemas.NextToken;
            oldest_id?: Schemas.OldestId;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2TweetsSearchRecentResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            newest_id?: Schemas.NewestId;
            next_token?: Schemas.NextToken;
            oldest_id?: Schemas.OldestId;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2TweetsSearchStreamResponse {
        data?: Schemas.Tweet;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2UsersByResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2UsersByUsernameUsernameResponse {
        data?: Schemas.User;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2UsersIdBlockingResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdBookmarksResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdFollowedListsResponse {
        data?: Schemas.List[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdFollowersResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdFollowingResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdLikedTweetsResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdListMembershipsResponse {
        data?: Schemas.List[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdMentionsResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            newest_id?: Schemas.NewestId;
            next_token?: Schemas.NextToken;
            oldest_id?: Schemas.OldestId;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdMutingResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdOwnedListsResponse {
        data?: Schemas.List[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            next_token?: Schemas.NextToken;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdPinnedListsResponse {
        data?: Schemas.List[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdResponse {
        data?: Schemas.User;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2UsersIdTimelinesReverseChronologicalResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            newest_id?: Schemas.NewestId;
            next_token?: Schemas.NextToken;
            oldest_id?: Schemas.OldestId;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersIdTweetsResponse {
        data?: Schemas.Tweet[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
        meta?: {
            newest_id?: Schemas.NewestId;
            next_token?: Schemas.NextToken;
            oldest_id?: Schemas.OldestId;
            previous_token?: Schemas.PreviousToken;
            result_count?: Schemas.ResultCount;
        };
    }
    export interface Get2UsersMeResponse {
        data?: Schemas.User;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export interface Get2UsersResponse {
        data?: Schemas.User[];
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    export type HashtagEntity = Schemas.EntityIndicesInclusiveExclusive & Schemas.HashtagFields;
    /** Represent the portion of text recognized as a Hashtag, and its start and end position within the text. */
    export interface HashtagFields {
        /** The text of the Hashtag. */
        tag: string;
    }
    /** HTTP Status Code. */
    export type HttpStatusCode = number;
    export type InvalidRequestProblem = Schemas.Problem & {
        errors?: {
            message?: string;
            parameters?: {
                [key: string]: string[];
            };
        }[];
    };
    export type InvalidRuleProblem = Schemas.Problem;
    /** Compliance Job ID. */
    export type JobId = string;
    /** A Twitter List is a curated group of accounts. */
    export interface List {
        created_at?: string;
        description?: string;
        follower_count?: number;
        id: Schemas.ListId;
        member_count?: number;
        /** The name of this List. */
        name: string;
        owner_id?: Schemas.UserId;
        private?: boolean;
    }
    export interface ListAddUserRequest {
        user_id: Schemas.UserId;
    }
    export interface ListCreateRequest {
        description?: string;
        name: string;
        private?: boolean;
    }
    export interface ListCreateResponse {
        /** A Twitter List is a curated group of accounts. */
        data?: {
            id: Schemas.ListId;
            /** The name of this List. */
            name: string;
        };
        errors?: Schemas.Problem[];
    }
    export interface ListDeleteResponse {
        data?: {
            deleted?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface ListFollowedRequest {
        list_id: Schemas.ListId;
    }
    export interface ListFollowedResponse {
        data?: {
            following?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    /** The unique identifier of this List. */
    export type ListId = string;
    export interface ListMutateResponse {
        data?: {
            is_member?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface ListPinnedRequest {
        list_id: Schemas.ListId;
    }
    export interface ListPinnedResponse {
        data?: {
            pinned?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface ListUnpinResponse {
        data?: {
            pinned?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface ListUpdateRequest {
        description?: string;
        name?: string;
        private?: boolean;
    }
    export interface ListUpdateResponse {
        data?: {
            updated?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface Media {
        height?: Schemas.MediaHeight;
        media_key?: Schemas.MediaKey;
        type: string;
        width?: Schemas.MediaWidth;
    }
    /** The height of the media in pixels. */
    export type MediaHeight = number;
    /** The unique identifier of this Media. */
    export type MediaId = string;
    /** The Media Key identifier for this attachment. */
    export type MediaKey = string;
    /** The width of the media in pixels. */
    export type MediaWidth = number;
    export type MentionEntity = Schemas.EntityIndicesInclusiveExclusive & Schemas.MentionFields;
    /** Represent the portion of text recognized as a User mention, and its start and end position within the text. */
    export interface MentionFields {
        id?: Schemas.UserId;
        username: Schemas.UserName;
    }
    export interface MuteUserMutationResponse {
        data?: {
            muting?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface MuteUserRequest {
        target_user_id: Schemas.UserId;
    }
    /** The newest id in this response. */
    export type NewestId = string;
    /** The next token. */
    export type NextToken = string;
    export type NonCompliantRulesProblem = Schemas.Problem;
    /** The oldest id in this response. */
    export type OldestId = string;
    export type OperationalDisconnectProblem = Schemas.Problem & {
        disconnect_type?: "OperationalDisconnect" | "UpstreamOperationalDisconnect" | "ForceDisconnect" | "UpstreamUncleanDisconnect" | "SlowReader" | "InternalError" | "ClientApplicationStateDegraded" | "InvalidRules";
    };
    /** A base32 pagination token. */
    export type PaginationToken32 = string;
    /** A base36 pagination token. */
    export type PaginationToken36 = string;
    /** A 'long' pagination token. */
    export type PaginationTokenLong = string;
    export type Photo = Schemas.Media & {
        alt_text?: string;
        url?: string;
    };
    export interface Place {
        contained_within?: Schemas.PlaceId[];
        /** The full name of the county in which this place exists. */
        country?: string;
        country_code?: Schemas.CountryCode;
        /** The full name of this place. */
        full_name: string;
        geo?: Schemas.Geo;
        id: Schemas.PlaceId;
        /** The human readable name of this place. */
        name?: string;
        place_type?: Schemas.PlaceType;
    }
    /** The identifier for this place. */
    export type PlaceId = string;
    export type PlaceType = "poi" | "neighborhood" | "city" | "admin" | "country" | "unknown";
    /** A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object. */
    export interface Point {
        coordinates: Schemas.Position;
        type: "Point";
    }
    /** Represent a Poll attached to a Tweet. */
    export interface Poll {
        duration_minutes?: number;
        end_datetime?: string;
        id: Schemas.PollId;
        options: Schemas.PollOption[];
        voting_status?: "open" | "closed";
    }
    /** Unique identifier of this poll. */
    export type PollId = string;
    /** Describes a choice in a Poll object. */
    export interface PollOption {
        label: Schemas.PollOptionLabel;
        /** Position of this choice in the poll. */
        position: number;
        /** Number of users who voted for this choice. */
        votes: number;
    }
    /** The text of a poll choice. */
    export type PollOptionLabel = string;
    /** A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`. */
    export type Position = number[];
    /** The previous token. */
    export type PreviousToken = string;
    /** An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807). */
    export interface Problem {
        detail?: string;
        status?: number;
        title: string;
        type: string;
    }
    export interface ProblemErrors {
        errors: Schemas.Problems;
    }
    export type ProblemOrError = Schemas.Error | Schemas.Problem;
    export type Problems = Schemas.Problem[];
    /** Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following. */
    export type ReplySettings = "everyone" | "mentionedUsers" | "following" | "other";
    export interface ReportUsersRequest {
        description: string;
        user_ids: Schemas.UserId[];
    }
    export interface ReportUsersResponse {
        data?: {
            id?: number;
        };
    }
    export type ResourceNotFoundProblem = Schemas.Problem & {
        parameter: string;
        resource_id: string;
        resource_type: "user" | "tweet" | "media" | "list" | "space";
        /** Value will match the schema of the field. */
        value: string;
    };
    export type ResourceUnauthorizedProblem = Schemas.Problem & {
        parameter: string;
        resource_id: string;
        resource_type: "user" | "tweet" | "media" | "list" | "space";
        section: "data" | "includes";
        value: string;
    };
    export type ResourceUnavailableProblem = Schemas.Problem & {
        parameter: string;
        resource_id: string;
        resource_type: "user" | "tweet" | "media" | "list" | "space";
    };
    /** The number of results returned in this response. */
    export type ResultCount = number;
    /** A user-provided stream filtering rule. */
    export interface Rule {
        id?: Schemas.RuleId;
        tag?: Schemas.RuleTag;
        value: Schemas.RuleValue;
    }
    /** Unique identifier of this rule. */
    export type RuleId = string;
    /** A user-provided stream filtering rule. */
    export interface RuleNoId {
        tag?: Schemas.RuleTag;
        value: Schemas.RuleValue;
    }
    /** A tag meant for the labeling of user provided rules. */
    export type RuleTag = string;
    /** The filterlang value of the rule. */
    export type RuleValue = string;
    export type RulesCapProblem = Schemas.Problem;
    export interface RulesLookupResponse {
        data?: Schemas.Rule[];
        meta: Schemas.RulesResponseMetadata;
    }
    export type RulesRequestSummary = {
        /** Number of user-specified stream filtering rules that were created. */
        created: number;
        /** Number of invalid user-specified stream filtering rules. */
        invalid: number;
        /** Number of user-specified stream filtering rules that were not created. */
        not_created: number;
        /** Number of valid user-specified stream filtering rules. */
        valid: number;
    } | {
        /** Number of user-specified stream filtering rules that were deleted. */
        deleted: number;
        /** Number of user-specified stream filtering rules that were not deleted. */
        not_deleted: number;
    };
    export interface RulesResponseMetadata {
        next_token?: Schemas.NextToken;
        /** Number of Rules in result set. */
        result_count?: number;
        sent: string;
        summary?: Schemas.RulesRequestSummary;
    }
    /** Represent a Search Count Result. */
    export interface SearchCount {
        end: Schemas.End;
        start: Schemas.Start;
        tweet_count: Schemas.TweetCount;
    }
    export interface Space {
        /** Creation time of the Space. */
        created_at?: string;
        creator_id?: Schemas.UserId;
        /** End time of the Space. */
        ended_at?: string;
        /** The user ids for the hosts of the Space. */
        host_ids?: Schemas.UserId[];
        id: Schemas.SpaceId;
        /** An array of user ids for people who were invited to a Space. */
        invited_user_ids?: Schemas.UserId[];
        /** Denotes if the Space is a ticketed Space. */
        is_ticketed?: boolean;
        /** The language of the Space. */
        lang?: string;
        /** The number of participants in a Space. */
        participant_count?: number;
        /** A date time stamp for when a Space is scheduled to begin. */
        scheduled_start?: string;
        /** An array of user ids for people who were speakers in a Space. */
        speaker_ids?: Schemas.UserId[];
        /** When the Space was started as a date string. */
        started_at?: string;
        /** The current state of the Space. */
        state: "live" | "scheduled" | "ended";
        /** The number of people who have either purchased a ticket or set a reminder for this Space. */
        subscriber_count?: number;
        /** The title of the Space. */
        title?: string;
        /** The topics of a Space, as selected by its creator. */
        topics?: {
            /** The description of the given topic. */
            description?: string;
            /** An ID suitable for use in the REST API. */
            id: string;
            /** The name of the given topic. */
            name: string;
        }[];
        /** When the Space was last updated. */
        updated_at?: string;
    }
    /** The unique identifier of this Space. */
    export type SpaceId = string;
    /** The start time of the bucket. */
    export type Start = string;
    export interface StreamingTweetResponse {
        data?: Schemas.Tweet;
        errors?: Schemas.Problem[];
        includes?: Schemas.Expansions;
    }
    /** The topic of a Space, as selected by its creator. */
    export interface Topic {
        /** The description of the given topic. */
        description?: string;
        id: Schemas.TopicId;
        /** The name of the given topic. */
        name: string;
    }
    /** Unique identifier of this Topic. */
    export type TopicId = string;
    export interface Tweet {
        /** Specifies the type of attachments (if any) present in this Tweet. */
        attachments?: {
            /** A list of Media Keys for each one of the media attachments (if media are attached). */
            media_keys?: Schemas.MediaKey[];
            /** A list of poll IDs (if polls are attached). */
            poll_ids?: Schemas.PollId[];
        };
        author_id?: Schemas.UserId;
        context_annotations?: Schemas.ContextAnnotation[];
        conversation_id?: Schemas.TweetId;
        /** Creation time of the Tweet. */
        created_at?: string;
        edit_controls?: {
            /** Time when Tweet is no longer editable. */
            editable_until: string;
            /** Number of times this Tweet can be edited. */
            edits_remaining: number;
            /** Indicates if this Tweet is eligible to be edited. */
            is_edit_eligible: boolean;
        };
        /** A list of Tweet Ids in this Tweet chain. */
        edit_history_tweet_ids: Schemas.TweetId[];
        entities?: Schemas.FullTextEntities;
        /** The location tagged on the Tweet, if the user provided one. */
        geo?: {
            coordinates?: Schemas.Point;
            place_id?: Schemas.PlaceId;
        };
        id: Schemas.TweetId;
        in_reply_to_user_id?: Schemas.UserId;
        /** Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag. */
        lang?: string;
        /** Nonpublic engagement metrics for the Tweet at the time of the request. */
        non_public_metrics?: {
            /** Number of times this Tweet has been viewed. */
            impression_count?: number;
        };
        /** Organic nonpublic engagement metrics for the Tweet at the time of the request. */
        organic_metrics?: {
            /** Number of times this Tweet has been viewed. */
            impression_count: number;
            /** Number of times this Tweet has been liked. */
            like_count: number;
            /** Number of times this Tweet has been replied to. */
            reply_count: number;
            /** Number of times this Tweet has been Retweeted. */
            retweet_count: number;
        };
        /** Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences. */
        possibly_sensitive?: boolean;
        /** Promoted nonpublic engagement metrics for the Tweet at the time of the request. */
        promoted_metrics?: {
            /** Number of times this Tweet has been viewed. */
            impression_count?: number;
            /** Number of times this Tweet has been liked. */
            like_count?: number;
            /** Number of times this Tweet has been replied to. */
            reply_count?: number;
            /** Number of times this Tweet has been Retweeted. */
            retweet_count?: number;
        };
        /** Engagement metrics for the Tweet at the time of the request. */
        public_metrics?: {
            /** Number of times this Tweet has been liked. */
            like_count: number;
            /** Number of times this Tweet has been quoted. */
            quote_count?: number;
            /** Number of times this Tweet has been replied to. */
            reply_count: number;
            /** Number of times this Tweet has been Retweeted. */
            retweet_count: number;
        };
        /** A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent. */
        referenced_tweets?: {
            id: Schemas.TweetId;
            type: "retweeted" | "quoted" | "replied_to";
        }[];
        reply_settings?: Schemas.ReplySettings;
        /** The name of the app the user Tweeted from. */
        source?: string;
        text: Schemas.TweetText;
        withheld?: Schemas.TweetWithheld;
    }
    export type TweetComplianceData = Schemas.TweetDeleteComplianceSchema | Schemas.TweetWithheldComplianceSchema | Schemas.TweetDropComplianceSchema | Schemas.TweetUndropComplianceSchema | Schemas.TweetEditComplianceSchema;
    export interface TweetComplianceSchema {
        /** Event time. */
        event_at: string;
        quote_tweet_id?: Schemas.TweetId;
        tweet: {
            author_id: Schemas.UserId;
            id: Schemas.TweetId;
        };
    }
    export type TweetComplianceStreamResponse = {
        data: Schemas.TweetComplianceData;
    } | {
        errors: Schemas.Problem[];
    };
    /** The count for the bucket. */
    export type TweetCount = number;
    export interface TweetCreateRequest {
        /** Card Uri Parameter. This is mutually exclusive from Quote Tweet Id, Poll, Media, and Direct Message Deep Link. */
        card_uri?: string;
        /** Link to take the conversation from the public timeline to a private Direct Message. */
        direct_message_deep_link?: string;
        /** Exclusive Tweet for super followers. */
        for_super_followers_only?: boolean;
        /** Place ID being attached to the Tweet for geo location. */
        geo?: {
            place_id?: string;
        };
        /** Media information being attached to created Tweet. This is mutually exclusive from Quote Tweet Id, Poll, and Card URI. */
        media?: {
            /** A list of Media Ids to be attached to a created Tweet. */
            media_ids: Schemas.MediaId[];
            /** A list of User Ids to be tagged in the media for created Tweet. */
            tagged_user_ids?: Schemas.UserId[];
        };
        /** Nullcasted (promoted-only) Tweets do not appear in the public timeline and are not served to followers. */
        nullcast?: boolean;
        /** Poll options for a Tweet with a poll. This is mutually exclusive from Media, Quote Tweet Id, and Card URI. */
        poll?: {
            /** Duration of the poll in minutes. */
            duration_minutes: number;
            options: string[];
            /** Settings to indicate who can reply to the Tweet. */
            reply_settings?: "following" | "mentionedUsers";
        };
        quote_tweet_id?: Schemas.TweetId;
        /** Tweet information of the Tweet being replied to. */
        reply?: {
            /** A list of User Ids to be excluded from the reply Tweet. */
            exclude_reply_user_ids?: Schemas.UserId[];
            in_reply_to_tweet_id: Schemas.TweetId;
        };
        /** Settings to indicate who can reply to the Tweet. */
        reply_settings?: "following" | "mentionedUsers";
        text?: Schemas.TweetText;
    }
    export interface TweetCreateResponse {
        data?: {
            id: Schemas.TweetId;
            text: Schemas.TweetText;
        };
        errors?: Schemas.Problem[];
    }
    export interface TweetDeleteComplianceSchema {
        delete: Schemas.TweetComplianceSchema;
    }
    export interface TweetDeleteResponse {
        data?: {
            deleted: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface TweetDropComplianceSchema {
        drop: Schemas.TweetComplianceSchema;
    }
    export interface TweetEditComplianceObjectSchema {
        edit_tweet_ids: Schemas.TweetId[];
        /** Event time. */
        event_at: string;
        initial_tweet_id: Schemas.TweetId;
        tweet: {
            id: Schemas.TweetId;
        };
    }
    export interface TweetEditComplianceSchema {
        tweet_edit: Schemas.TweetEditComplianceObjectSchema;
    }
    export interface TweetHideRequest {
        hidden: boolean;
    }
    export interface TweetHideResponse {
        data?: {
            hidden?: boolean;
        };
    }
    /** Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers. */
    export type TweetId = string;
    export interface TweetTakedownComplianceSchema {
        /** Event time. */
        event_at: string;
        quote_tweet_id?: Schemas.TweetId;
        tweet: {
            author_id: Schemas.UserId;
            id: Schemas.TweetId;
        };
        withheld_in_countries: Schemas.CountryCode[];
    }
    /** The content of the Tweet. */
    export type TweetText = string;
    export interface TweetUndropComplianceSchema {
        undrop: Schemas.TweetComplianceSchema;
    }
    /** Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country). */
    export interface TweetWithheld {
        /** Indicates if the content is being withheld for on the basis of copyright infringement. */
        copyright: boolean;
        /** Provides a list of countries where this content is not available. */
        country_codes: Schemas.CountryCode[];
        /** Indicates whether the content being withheld is the `tweet` or a `user`. */
        scope?: "tweet" | "user";
    }
    export interface TweetWithheldComplianceSchema {
        withheld: Schemas.TweetTakedownComplianceSchema;
    }
    export type UnsupportedAuthenticationProblem = Schemas.Problem;
    /** Expiration time of the upload URL. */
    export type UploadExpiration = string;
    /** URL to which the user will upload their Tweet or user IDs. */
    export type UploadUrl = string;
    /** A validly formatted URL. */
    export type Url = string;
    export type UrlEntity = Schemas.EntityIndicesInclusiveExclusive & Schemas.UrlFields;
    /** Represent the portion of text recognized as a URL. */
    export interface UrlFields {
        /** Description of the URL landing page. */
        description?: string;
        /** The URL as displayed in the Twitter client. */
        display_url?: string;
        expanded_url?: Schemas.Url;
        images?: Schemas.UrlImage[];
        media_key?: Schemas.MediaKey;
        status?: Schemas.HttpStatusCode;
        /** Title of the page the URL points to. */
        title?: string;
        /** Fully resolved url. */
        unwound_url?: string;
        url: Schemas.Url;
    }
    /** Represent the information for the URL image. */
    export interface UrlImage {
        height?: Schemas.MediaHeight;
        url?: Schemas.Url;
        width?: Schemas.MediaWidth;
    }
    export type UsageCapExceededProblem = Schemas.Problem & {
        period?: "Daily" | "Monthly";
        scope?: "Account" | "Product";
    };
    /** The Twitter User object. */
    export interface User {
        /** Creation time of this User. */
        created_at?: string;
        /** The text of this User's profile description (also known as bio), if the User provided one. */
        description?: string;
        /** A list of metadata found in the User's profile description. */
        entities?: {
            description?: Schemas.FullTextEntities;
            /** Expanded details for the URL specified in the User's profile, with start and end indices. */
            url?: {
                urls?: Schemas.UrlEntity[];
            };
        };
        id: Schemas.UserId;
        /** The location specified in the User's profile, if the User provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries. */
        location?: string;
        /** The friendly name of this User, as shown on their profile. */
        name: string;
        pinned_tweet_id?: Schemas.TweetId;
        /** The URL to the profile image for this User. */
        profile_image_url?: string;
        /** Indicates if this User has chosen to protect their Tweets (in other words, if this User's Tweets are private). */
        protected?: boolean;
        /** A list of metrics for this User. */
        public_metrics?: {
            /** Number of Users who are following this User. */
            followers_count: number;
            /** Number of Users this User is following. */
            following_count: number;
            /** The number of lists that include this User. */
            listed_count: number;
            /** The number of Tweets (including Retweets) posted by this User. */
            tweet_count: number;
        };
        /** The URL specified in the User's profile. */
        url?: string;
        username: Schemas.UserName;
        /** Indicate if this User is a verified Twitter User. */
        verified?: boolean;
        withheld?: Schemas.UserWithheld;
    }
    export type UserComplianceData = Schemas.UserProtectComplianceSchema | Schemas.UserUnprotectComplianceSchema | Schemas.UserDeleteComplianceSchema | Schemas.UserUndeleteComplianceSchema | Schemas.UserSuspendComplianceSchema | Schemas.UserUnsuspendComplianceSchema | Schemas.UserWithheldComplianceSchema | Schemas.UserScrubGeoSchema | Schemas.UserProfileModificationComplianceSchema;
    export interface UserComplianceSchema {
        /** Event time. */
        event_at: string;
        user: {
            id: Schemas.UserId;
        };
    }
    export type UserComplianceStreamResponse = {
        data: Schemas.UserComplianceData;
    } | {
        errors: Schemas.Problem[];
    };
    export interface UserDeleteComplianceSchema {
        user_delete: Schemas.UserComplianceSchema;
    }
    /** Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers. */
    export type UserId = string;
    /** Unique identifier of this User. The value must be the same as the authenticated user. */
    export type UserIdMatchesAuthenticatedUser = string;
    /** The Twitter handle (screen name) of this user. */
    export type UserName = string;
    export interface UserProfileModificationComplianceSchema {
        user_profile_modification: Schemas.UserProfileModificationObjectSchema;
    }
    export interface UserProfileModificationObjectSchema {
        /** Event time. */
        event_at: string;
        new_value: string;
        profile_field: string;
        user: {
            id: Schemas.UserId;
        };
    }
    export interface UserProtectComplianceSchema {
        user_protect: Schemas.UserComplianceSchema;
    }
    export interface UserScrubGeoObjectSchema {
        /** Event time. */
        event_at: string;
        up_to_tweet_id: Schemas.TweetId;
        user: {
            id: Schemas.UserId;
        };
    }
    export interface UserScrubGeoSchema {
        scrub_geo: Schemas.UserScrubGeoObjectSchema;
    }
    export interface UserSuspendComplianceSchema {
        user_suspend: Schemas.UserComplianceSchema;
    }
    export interface UserTakedownComplianceSchema {
        /** Event time. */
        event_at: string;
        user: {
            id: Schemas.UserId;
        };
        withheld_in_countries: Schemas.CountryCode[];
    }
    export interface UserUndeleteComplianceSchema {
        user_undelete: Schemas.UserComplianceSchema;
    }
    export interface UserUnprotectComplianceSchema {
        user_unprotect: Schemas.UserComplianceSchema;
    }
    export interface UserUnsuspendComplianceSchema {
        user_unsuspend: Schemas.UserComplianceSchema;
    }
    /** Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country). */
    export interface UserWithheld {
        /** Provides a list of countries where this content is not available. */
        country_codes: Schemas.CountryCode[];
        /** Indicates that the content being withheld is a `user`. */
        scope?: "user";
    }
    export interface UserWithheldComplianceSchema {
        user_withheld: Schemas.UserTakedownComplianceSchema;
    }
    export interface UsersFollowingCreateRequest {
        target_user_id: Schemas.UserId;
    }
    export interface UsersFollowingCreateResponse {
        data?: {
            following?: boolean;
            pending_follow?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface UsersFollowingDeleteResponse {
        data?: {
            following?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface UsersLikesCreateRequest {
        tweet_id: Schemas.TweetId;
    }
    export interface UsersLikesCreateResponse {
        data?: {
            liked?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface UsersLikesDeleteResponse {
        data?: {
            liked?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface UsersRetweetsCreateRequest {
        tweet_id: Schemas.TweetId;
    }
    export interface UsersRetweetsCreateResponse {
        data?: {
            retweeted?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface UsersRetweetsDeleteResponse {
        data?: {
            retweeted?: boolean;
        };
        errors?: Schemas.Problem[];
    }
    export interface Variant {
        /** The bit rate of the media. */
        bit_rate?: number;
        /** The content type of the media. */
        content_type?: string;
        /** The url to the media. */
        url?: string;
    }
    /** An array of all available variants of the media. */
    export type Variants = Schemas.Variant[];
    export type Video = Schemas.Media & {
        duration_ms?: number;
        /** Nonpublic engagement metrics for the Media at the time of the request. */
        non_public_metrics?: {
            /** Number of users who made it through 0% of the video. */
            playback_0_count?: number;
            /** Number of users who made it through 100% of the video. */
            playback_100_count?: number;
            /** Number of users who made it through 25% of the video. */
            playback_25_count?: number;
            /** Number of users who made it through 50% of the video. */
            playback_50_count?: number;
            /** Number of users who made it through 75% of the video. */
            playback_75_count?: number;
        };
        /** Organic nonpublic engagement metrics for the Media at the time of the request. */
        organic_metrics?: {
            /** Number of users who made it through 0% of the video. */
            playback_0_count?: number;
            /** Number of users who made it through 100% of the video. */
            playback_100_count?: number;
            /** Number of users who made it through 25% of the video. */
            playback_25_count?: number;
            /** Number of users who made it through 50% of the video. */
            playback_50_count?: number;
            /** Number of users who made it through 75% of the video. */
            playback_75_count?: number;
            /** Number of times this video has been viewed. */
            view_count?: number;
        };
        preview_image_url?: string;
        /** Promoted nonpublic engagement metrics for the Media at the time of the request. */
        promoted_metrics?: {
            /** Number of users who made it through 0% of the video. */
            playback_0_count?: number;
            /** Number of users who made it through 100% of the video. */
            playback_100_count?: number;
            /** Number of users who made it through 25% of the video. */
            playback_25_count?: number;
            /** Number of users who made it through 50% of the video. */
            playback_50_count?: number;
            /** Number of users who made it through 75% of the video. */
            playback_75_count?: number;
            /** Number of times this video has been viewed. */
            view_count?: number;
        };
        /** Engagement metrics for the Media at the time of the request. */
        public_metrics?: {
            /** Number of times this video has been viewed. */
            view_count?: number;
        };
        variants?: Schemas.Variants;
    };
}
export namespace Parameters {
    /** A comma separated list of ComplianceJob fields to display. */
    export type ComplianceJobFieldsParameter = ("created_at" | "download_expires_at" | "download_url" | "id" | "name" | "resumable" | "status" | "type" | "upload_expires_at" | "upload_url")[];
    /** A comma separated list of fields to expand. */
    export type ListExpansionsParameter = ("owner_id")[];
    /** A comma separated list of List fields to display. */
    export type ListFieldsParameter = ("created_at" | "description" | "follower_count" | "id" | "member_count" | "name" | "owner_id" | "private")[];
    /** A comma separated list of Media fields to display. */
    export type MediaFieldsParameter = ("alt_text" | "duration_ms" | "height" | "media_key" | "non_public_metrics" | "organic_metrics" | "preview_image_url" | "promoted_metrics" | "public_metrics" | "type" | "url" | "variants" | "width")[];
    /** A comma separated list of Place fields to display. */
    export type PlaceFieldsParameter = ("contained_within" | "country" | "country_code" | "full_name" | "geo" | "id" | "name" | "place_type")[];
    /** A comma separated list of Poll fields to display. */
    export type PollFieldsParameter = ("duration_minutes" | "end_datetime" | "id" | "options" | "voting_status")[];
    /** A comma separated list of SearchCount fields to display. */
    export type SearchCountFieldsParameter = ("end" | "start" | "tweet_count")[];
    /** A comma separated list of fields to expand. */
    export type SpaceExpansionsParameter = ("creator_id" | "host_ids" | "invited_user_ids" | "speaker_ids" | "topic_ids")[];
    /** A comma separated list of Space fields to display. */
    export type SpaceFieldsParameter = ("created_at" | "creator_id" | "ended_at" | "host_ids" | "id" | "invited_user_ids" | "is_ticketed" | "lang" | "participant_count" | "scheduled_start" | "speaker_ids" | "started_at" | "state" | "subscriber_count" | "title" | "topic_ids" | "updated_at")[];
    /** A comma separated list of Topic fields to display. */
    export type TopicFieldsParameter = ("description" | "id" | "name")[];
    /** A comma separated list of fields to expand. */
    export type TweetExpansionsParameter = ("attachments.media_keys" | "attachments.poll_ids" | "author_id" | "edit_history_tweet_ids" | "entities.mentions.username" | "geo.place_id" | "in_reply_to_user_id" | "referenced_tweets.id" | "referenced_tweets.id.author_id")[];
    /** A comma separated list of Tweet fields to display. */
    export type TweetFieldsParameter = ("attachments" | "author_id" | "context_annotations" | "conversation_id" | "created_at" | "edit_controls" | "edit_history_tweet_ids" | "entities" | "geo" | "id" | "in_reply_to_user_id" | "lang" | "non_public_metrics" | "organic_metrics" | "possibly_sensitive" | "promoted_metrics" | "public_metrics" | "referenced_tweets" | "reply_settings" | "source" | "text" | "withheld")[];
    /** A comma separated list of fields to expand. */
    export type UserExpansionsParameter = ("pinned_tweet_id")[];
    /** A comma separated list of User fields to display. */
    export type UserFieldsParameter = ("created_at" | "description" | "entities" | "id" | "location" | "name" | "pinned_tweet_id" | "profile_image_url" | "protected" | "public_metrics" | "url" | "username" | "verified" | "withheld")[];
}
export interface Parameter$listBatchComplianceJobs {
    /** Type of Compliance Job to list. */
    type: "tweets" | "users";
    /** Status of Compliance Job to list. */
    status?: "created" | "in_progress" | "failed" | "complete";
    /** A comma separated list of ComplianceJob fields to display. */
    "compliance_job.fields"?: Parameters.ComplianceJobFieldsParameter;
}
export interface Response$listBatchComplianceJobs$Status$200 {
    "application/json": Schemas.Get2ComplianceJobsResponse;
}
export interface Response$listBatchComplianceJobs$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface RequestBody$createBatchComplianceJob {
    "application/json": Schemas.CreateComplianceJobRequest;
}
export interface Response$createBatchComplianceJob$Status$200 {
    "application/json": Schemas.CreateComplianceJobResponse;
}
export interface Response$createBatchComplianceJob$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$getBatchComplianceJob {
    /** The ID of the Compliance Job to retrieve. */
    id: Schemas.JobId;
    /** A comma separated list of ComplianceJob fields to display. */
    "compliance_job.fields"?: Parameters.ComplianceJobFieldsParameter;
}
export interface Response$getBatchComplianceJob$Status$200 {
    "application/json": Schemas.Get2ComplianceJobsIdResponse;
}
export interface Response$getBatchComplianceJob$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface RequestBody$listIdCreate {
    "application/json": Schemas.ListCreateRequest;
}
export interface Response$listIdCreate$Status$200 {
    "application/json": Schemas.ListCreateResponse;
}
export interface Response$listIdCreate$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listIdGet {
    /** The ID of the List. */
    id: Schemas.ListId;
    /** A comma separated list of List fields to display. */
    "list.fields"?: Parameters.ListFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.ListExpansionsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
}
export interface Response$listIdGet$Status$200 {
    "application/json": Schemas.Get2ListsIdResponse;
}
export interface Response$listIdGet$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listIdUpdate {
    /** The ID of the List to modify. */
    id: Schemas.ListId;
}
export interface RequestBody$listIdUpdate {
    "application/json": Schemas.ListUpdateRequest;
}
export interface Response$listIdUpdate$Status$200 {
    "application/json": Schemas.ListUpdateResponse;
}
export interface Response$listIdUpdate$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listIdDelete {
    /** The ID of the List to delete. */
    id: Schemas.ListId;
}
export interface Response$listIdDelete$Status$200 {
    "application/json": Schemas.ListDeleteResponse;
}
export interface Response$listIdDelete$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listGetFollowers {
    /** The ID of the List. */
    id: Schemas.ListId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationTokenLong;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$listGetFollowers$Status$200 {
    "application/json": Schemas.Get2ListsIdFollowersResponse;
}
export interface Response$listGetFollowers$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listGetMembers {
    /** The ID of the List. */
    id: Schemas.ListId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationTokenLong;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$listGetMembers$Status$200 {
    "application/json": Schemas.Get2ListsIdMembersResponse;
}
export interface Response$listGetMembers$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listAddMember {
    /** The ID of the List for which to add a member. */
    id: Schemas.ListId;
}
export interface RequestBody$listAddMember {
    "application/json": Schemas.ListAddUserRequest;
}
export interface Response$listAddMember$Status$200 {
    "application/json": Schemas.ListMutateResponse;
}
export interface Response$listAddMember$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listRemoveMember {
    /** The ID of the List to remove a member. */
    id: Schemas.ListId;
    /** The ID of User that will be removed from the List. */
    user_id: Schemas.UserId;
}
export interface Response$listRemoveMember$Status$200 {
    "application/json": Schemas.ListMutateResponse;
}
export interface Response$listRemoveMember$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listsIdTweets {
    /** The ID of the List. */
    id: Schemas.ListId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token?: Schemas.PaginationToken36;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$listsIdTweets$Status$200 {
    "application/json": Schemas.Get2ListsIdTweetsResponse;
}
export interface Response$listsIdTweets$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Response$getOpenApiSpec$Status$200 {
    "application/json": {};
}
export interface Parameter$findSpacesByIds {
    /** The list of Space IDs to return. */
    ids: string[];
    /** A comma separated list of Space fields to display. */
    "space.fields"?: Parameters.SpaceFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.SpaceExpansionsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Topic fields to display. */
    "topic.fields"?: Parameters.TopicFieldsParameter;
}
export interface Response$findSpacesByIds$Status$200 {
    "application/json": Schemas.Get2SpacesResponse;
}
export interface Response$findSpacesByIds$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findSpacesByCreatorIds {
    /** The IDs of Users to search through. */
    user_ids: Schemas.UserId[];
    /** A comma separated list of Space fields to display. */
    "space.fields"?: Parameters.SpaceFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.SpaceExpansionsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Topic fields to display. */
    "topic.fields"?: Parameters.TopicFieldsParameter;
}
export interface Response$findSpacesByCreatorIds$Status$200 {
    "application/json": Schemas.Get2SpacesByCreatorIdsResponse;
}
export interface Response$findSpacesByCreatorIds$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$searchSpaces {
    /** The search query. */
    query: string;
    /** The state of Spaces to search for. */
    state?: "live" | "scheduled" | "all";
    /** The number of results to return. */
    max_results?: number;
    /** A comma separated list of Space fields to display. */
    "space.fields"?: Parameters.SpaceFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.SpaceExpansionsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Topic fields to display. */
    "topic.fields"?: Parameters.TopicFieldsParameter;
}
export interface Response$searchSpaces$Status$200 {
    "application/json": Schemas.Get2SpacesSearchResponse;
}
export interface Response$searchSpaces$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findSpaceById {
    /** The ID of the Space to be retrieved. */
    id: string;
    /** A comma separated list of Space fields to display. */
    "space.fields"?: Parameters.SpaceFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.SpaceExpansionsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Topic fields to display. */
    "topic.fields"?: Parameters.TopicFieldsParameter;
}
export interface Response$findSpaceById$Status$200 {
    "application/json": Schemas.Get2SpacesIdResponse;
}
export interface Response$findSpaceById$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$spaceBuyers {
    /** The ID of the Space to be retrieved. */
    id: string;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationToken32;
    /** The maximum number of results. */
    max_results?: number;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$spaceBuyers$Status$200 {
    "application/json": Schemas.Get2SpacesIdBuyersResponse;
}
export interface Response$spaceBuyers$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$spaceTweets {
    /** The ID of the Space to be retrieved. */
    id: string;
    /** The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. */
    max_results?: number;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$spaceTweets$Status$200 {
    "application/json": Schemas.Get2SpacesIdTweetsResponse;
}
export interface Response$spaceTweets$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findTweetsById {
    /** A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. */
    ids: Schemas.TweetId[];
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$findTweetsById$Status$200 {
    "application/json": Schemas.Get2TweetsResponse;
}
export interface Response$findTweetsById$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface RequestBody$createTweet {
    "application/json": Schemas.TweetCreateRequest;
}
export interface Response$createTweet$Status$201 {
    "application/json": Schemas.TweetCreateResponse;
}
export interface Response$createTweet$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$getTweetsComplianceStream {
    /** The number of minutes of backfill requested. */
    backfill_minutes?: number;
    /** The partition number. */
    partition: number;
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet Compliance events will be provided. */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweet Compliance events will be provided. */
    end_time?: string;
}
export interface Response$getTweetsComplianceStream$Status$200 {
    "application/json": Schemas.TweetComplianceStreamResponse;
}
export interface Response$getTweetsComplianceStream$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$tweetCountsFullArchiveSearch {
    /** One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. */
    query: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). */
    end_time?: string;
    /** Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. */
    since_id?: Schemas.TweetId;
    /** Returns results with a Tweet ID less than (that is, older than) the specified ID. */
    until_id?: Schemas.TweetId;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    next_token?: Schemas.PaginationToken36;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    pagination_token?: Schemas.PaginationToken36;
    /** The granularity for the search counts results. */
    granularity?: "minute" | "hour" | "day";
    /** A comma separated list of SearchCount fields to display. */
    "search_count.fields"?: Parameters.SearchCountFieldsParameter;
}
export interface Response$tweetCountsFullArchiveSearch$Status$200 {
    "application/json": Schemas.Get2TweetsCountsAllResponse;
}
export interface Response$tweetCountsFullArchiveSearch$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$tweetCountsRecentSearch {
    /** One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. */
    query: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). */
    end_time?: string;
    /** Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. */
    since_id?: Schemas.TweetId;
    /** Returns results with a Tweet ID less than (that is, older than) the specified ID. */
    until_id?: Schemas.TweetId;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    next_token?: Schemas.PaginationToken36;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    pagination_token?: Schemas.PaginationToken36;
    /** The granularity for the search counts results. */
    granularity?: "minute" | "hour" | "day";
    /** A comma separated list of SearchCount fields to display. */
    "search_count.fields"?: Parameters.SearchCountFieldsParameter;
}
export interface Response$tweetCountsRecentSearch$Status$200 {
    "application/json": Schemas.Get2TweetsCountsRecentResponse;
}
export interface Response$tweetCountsRecentSearch$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$getTweetsFirehoseStream {
    /** The number of minutes of backfill requested. */
    backfill_minutes?: number;
    /** The partition number. */
    partition: number;
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. */
    end_time?: string;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$getTweetsFirehoseStream$Status$200 {
    "application/json": Schemas.StreamingTweetResponse;
}
export interface Response$getTweetsFirehoseStream$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$sampleStream {
    /** The number of minutes of backfill requested. */
    backfill_minutes?: number;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$sampleStream$Status$200 {
    "application/json": Schemas.StreamingTweetResponse;
}
export interface Response$sampleStream$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$getTweetsSample10Stream {
    /** The number of minutes of backfill requested. */
    backfill_minutes?: number;
    /** The partition number. */
    partition: number;
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided. */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. */
    end_time?: string;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$getTweetsSample10Stream$Status$200 {
    "application/json": Schemas.Get2TweetsSample10StreamResponse;
}
export interface Response$getTweetsSample10Stream$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$tweetsFullarchiveSearch {
    /** One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. */
    query: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). */
    end_time?: string;
    /** Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. */
    since_id?: Schemas.TweetId;
    /** Returns results with a Tweet ID less than (that is, older than) the specified ID. */
    until_id?: Schemas.TweetId;
    /** The maximum number of search results to be returned by a request. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    next_token?: Schemas.PaginationToken36;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    pagination_token?: Schemas.PaginationToken36;
    /** This order in which to return results. */
    sort_order?: "recency" | "relevancy";
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$tweetsFullarchiveSearch$Status$200 {
    "application/json": Schemas.Get2TweetsSearchAllResponse;
}
export interface Response$tweetsFullarchiveSearch$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$tweetsRecentSearch {
    /** One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. */
    query: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). */
    end_time?: string;
    /** Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. */
    since_id?: Schemas.TweetId;
    /** Returns results with a Tweet ID less than (that is, older than) the specified ID. */
    until_id?: Schemas.TweetId;
    /** The maximum number of search results to be returned by a request. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    next_token?: Schemas.PaginationToken36;
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. */
    pagination_token?: Schemas.PaginationToken36;
    /** This order in which to return results. */
    sort_order?: "recency" | "relevancy";
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$tweetsRecentSearch$Status$200 {
    "application/json": Schemas.Get2TweetsSearchRecentResponse;
}
export interface Response$tweetsRecentSearch$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$searchStream {
    /** The number of minutes of backfill requested. */
    backfill_minutes?: number;
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. */
    end_time?: string;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$searchStream$Status$200 {
    "application/json": Schemas.FilteredStreamingTweetResponse;
}
export interface Response$searchStream$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$getRules {
    /** A comma-separated list of Rule IDs. */
    ids?: Schemas.RuleId[];
    /** The maximum number of results. */
    max_results?: number;
    /** This value is populated by passing the 'next_token' returned in a request to paginate through results. */
    pagination_token?: string;
}
export interface Response$getRules$Status$200 {
    "application/json": Schemas.RulesLookupResponse;
}
export interface Response$getRules$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$addOrDeleteRules {
    /** Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. */
    dry_run?: boolean;
}
export interface RequestBody$addOrDeleteRules {
    "application/json": Schemas.AddOrDeleteRulesRequest;
}
export interface Response$addOrDeleteRules$Status$200 {
    "application/json": Schemas.AddOrDeleteRulesResponse;
}
export interface Response$addOrDeleteRules$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findTweetById {
    /** A single Tweet ID. */
    id: Schemas.TweetId;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$findTweetById$Status$200 {
    "application/json": Schemas.Get2TweetsIdResponse;
}
export interface Response$findTweetById$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$deleteTweetById {
    /** The ID of the Tweet to be deleted. */
    id: Schemas.TweetId;
}
export interface Response$deleteTweetById$Status$200 {
    "application/json": Schemas.TweetDeleteResponse;
}
export interface Response$deleteTweetById$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$tweetsIdLikingUsers {
    /** A single Tweet ID. */
    id: Schemas.TweetId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token?: Schemas.PaginationToken36;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$tweetsIdLikingUsers$Status$200 {
    "application/json": Schemas.Get2TweetsIdLikingUsersResponse;
}
export interface Response$tweetsIdLikingUsers$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findTweetsThatQuoteATweet {
    /** A single Tweet ID. */
    id: Schemas.TweetId;
    /** The maximum number of results to be returned. */
    max_results?: number;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationToken36;
    /** The set of entities to exclude (e.g. 'replies' or 'retweets'). */
    exclude?: ("replies" | "retweets")[];
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$findTweetsThatQuoteATweet$Status$200 {
    "application/json": Schemas.Get2TweetsIdQuoteTweetsResponse;
}
export interface Response$findTweetsThatQuoteATweet$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$tweetsIdRetweetingUsers {
    /** A single Tweet ID. */
    id: Schemas.TweetId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token?: Schemas.PaginationToken36;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$tweetsIdRetweetingUsers$Status$200 {
    "application/json": Schemas.Get2TweetsIdRetweetedByResponse;
}
export interface Response$tweetsIdRetweetingUsers$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$hideReplyById {
    /** The ID of the reply that you want to hide or unhide. */
    tweet_id: Schemas.TweetId;
}
export interface RequestBody$hideReplyById {
    "application/json": Schemas.TweetHideRequest;
}
export interface Response$hideReplyById$Status$200 {
    "application/json": Schemas.TweetHideResponse;
}
export interface Response$hideReplyById$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findUsersById {
    /** A list of User IDs, comma-separated. You can specify up to 100 IDs. */
    ids: Schemas.UserId[];
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$findUsersById$Status$200 {
    "application/json": Schemas.Get2UsersResponse;
}
export interface Response$findUsersById$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findUsersByUsername {
    /** A list of usernames, comma-separated. */
    usernames: string[];
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$findUsersByUsername$Status$200 {
    "application/json": Schemas.Get2UsersByResponse;
}
export interface Response$findUsersByUsername$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findUserByUsername {
    /** A username. */
    username: string;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$findUserByUsername$Status$200 {
    "application/json": Schemas.Get2UsersByUsernameUsernameResponse;
}
export interface Response$findUserByUsername$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$getUsersComplianceStream {
    /** The number of minutes of backfill requested. */
    backfill_minutes?: number;
    /** The partition number. */
    partition: number;
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided. */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided. */
    end_time?: string;
}
export interface Response$getUsersComplianceStream$Status$200 {
    "application/json": Schemas.UserComplianceStreamResponse;
}
export interface Response$getUsersComplianceStream$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findMyUser {
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$findMyUser$Status$200 {
    "application/json": Schemas.Get2UsersMeResponse;
}
export interface Response$findMyUser$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$findUserById {
    /** The ID of the User to lookup. */
    id: Schemas.UserId;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$findUserById$Status$200 {
    "application/json": Schemas.Get2UsersIdResponse;
}
export interface Response$findUserById$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdBlocking {
    /** The ID of the authenticated source User for whom to return results. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationToken32;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$usersIdBlocking$Status$200 {
    "application/json": Schemas.Get2UsersIdBlockingResponse;
}
export interface Response$usersIdBlocking$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdBlock {
    /** The ID of the authenticated source User that is requesting to block the target User. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
}
export interface RequestBody$usersIdBlock {
    "application/json": Schemas.BlockUserRequest;
}
export interface Response$usersIdBlock$Status$200 {
    "application/json": Schemas.BlockUserMutationResponse;
}
export interface Response$usersIdBlock$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$getUsersIdBookmarks {
    /** The ID of the authenticated source User for whom to return results. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token?: Schemas.PaginationToken36;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$getUsersIdBookmarks$Status$200 {
    "application/json": Schemas.Get2UsersIdBookmarksResponse;
}
export interface Response$getUsersIdBookmarks$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$postUsersIdBookmarks {
    /** The ID of the authenticated source User for whom to add bookmarks. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
}
export interface RequestBody$postUsersIdBookmarks {
    "application/json": Schemas.BookmarkAddRequest;
}
export interface Response$postUsersIdBookmarks$Status$200 {
    "application/json": Schemas.BookmarkMutationResponse;
}
export interface Response$postUsersIdBookmarks$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdBookmarksDelete {
    /** The ID of the authenticated source User whose bookmark is to be removed. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The ID of the Tweet that the source User is removing from bookmarks. */
    tweet_id: Schemas.TweetId;
}
export interface Response$usersIdBookmarksDelete$Status$200 {
    "application/json": Schemas.BookmarkMutationResponse;
}
export interface Response$usersIdBookmarksDelete$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$userFollowedLists {
    /** The ID of the User to lookup. */
    id: Schemas.UserId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationTokenLong;
    /** A comma separated list of List fields to display. */
    "list.fields"?: Parameters.ListFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.ListExpansionsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
}
export interface Response$userFollowedLists$Status$200 {
    "application/json": Schemas.Get2UsersIdFollowedListsResponse;
}
export interface Response$userFollowedLists$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listUserFollow {
    /** The ID of the authenticated source User that will follow the List. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
}
export interface RequestBody$listUserFollow {
    "application/json": Schemas.ListFollowedRequest;
}
export interface Response$listUserFollow$Status$200 {
    "application/json": Schemas.ListFollowedResponse;
}
export interface Response$listUserFollow$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listUserUnfollow {
    /** The ID of the authenticated source User that will unfollow the List. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The ID of the List to unfollow. */
    list_id: Schemas.ListId;
}
export interface Response$listUserUnfollow$Status$200 {
    "application/json": Schemas.ListFollowedResponse;
}
export interface Response$listUserUnfollow$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdFollowers {
    /** The ID of the User to lookup. */
    id: Schemas.UserId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationToken32;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$usersIdFollowers$Status$200 {
    "application/json": Schemas.Get2UsersIdFollowersResponse;
}
export interface Response$usersIdFollowers$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdFollowing {
    /** The ID of the User to lookup. */
    id: Schemas.UserId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationToken32;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$usersIdFollowing$Status$200 {
    "application/json": Schemas.Get2UsersIdFollowingResponse;
}
export interface Response$usersIdFollowing$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdFollow {
    /** The ID of the authenticated source User that is requesting to follow the target User. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
}
export interface RequestBody$usersIdFollow {
    "application/json": Schemas.UsersFollowingCreateRequest;
}
export interface Response$usersIdFollow$Status$200 {
    "application/json": Schemas.UsersFollowingCreateResponse;
}
export interface Response$usersIdFollow$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdLikedTweets {
    /** The ID of the User to lookup. */
    id: Schemas.UserId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token?: Schemas.PaginationToken36;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$usersIdLikedTweets$Status$200 {
    "application/json": Schemas.Get2UsersIdLikedTweetsResponse;
}
export interface Response$usersIdLikedTweets$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdLike {
    /** The ID of the authenticated source User that is requesting to like the Tweet. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
}
export interface RequestBody$usersIdLike {
    "application/json": Schemas.UsersLikesCreateRequest;
}
export interface Response$usersIdLike$Status$200 {
    "application/json": Schemas.UsersLikesCreateResponse;
}
export interface Response$usersIdLike$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdUnlike {
    /** The ID of the authenticated source User that is requesting to unlike the Tweet. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The ID of the Tweet that the User is requesting to unlike. */
    tweet_id: Schemas.TweetId;
}
export interface Response$usersIdUnlike$Status$200 {
    "application/json": Schemas.UsersLikesDeleteResponse;
}
export interface Response$usersIdUnlike$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$getUserListMemberships {
    /** The ID of the User to lookup. */
    id: Schemas.UserId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationTokenLong;
    /** A comma separated list of List fields to display. */
    "list.fields"?: Parameters.ListFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.ListExpansionsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
}
export interface Response$getUserListMemberships$Status$200 {
    "application/json": Schemas.Get2UsersIdListMembershipsResponse;
}
export interface Response$getUserListMemberships$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdMentions {
    /** The ID of the User to lookup. */
    id: Schemas.UserId;
    /** The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. */
    since_id?: Schemas.TweetId;
    /** The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. */
    until_id?: Schemas.TweetId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token?: Schemas.PaginationToken36;
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. */
    end_time?: string;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$usersIdMentions$Status$200 {
    "application/json": Schemas.Get2UsersIdMentionsResponse;
}
export interface Response$usersIdMentions$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdMuting {
    /** The ID of the authenticated source User for whom to return results. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token?: Schemas.PaginationTokenLong;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.UserExpansionsParameter;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
}
export interface Response$usersIdMuting$Status$200 {
    "application/json": Schemas.Get2UsersIdMutingResponse;
}
export interface Response$usersIdMuting$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdMute {
    /** The ID of the authenticated source User that is requesting to mute the target User. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
}
export interface RequestBody$usersIdMute {
    "application/json": Schemas.MuteUserRequest;
}
export interface Response$usersIdMute$Status$200 {
    "application/json": Schemas.MuteUserMutationResponse;
}
export interface Response$usersIdMute$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listUserOwnedLists {
    /** The ID of the User to lookup. */
    id: Schemas.UserId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get a specified 'page' of results. */
    pagination_token?: Schemas.PaginationTokenLong;
    /** A comma separated list of List fields to display. */
    "list.fields"?: Parameters.ListFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.ListExpansionsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
}
export interface Response$listUserOwnedLists$Status$200 {
    "application/json": Schemas.Get2UsersIdOwnedListsResponse;
}
export interface Response$listUserOwnedLists$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listUserPinnedLists {
    /** The ID of the authenticated source User for whom to return results. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** A comma separated list of List fields to display. */
    "list.fields"?: Parameters.ListFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.ListExpansionsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
}
export interface Response$listUserPinnedLists$Status$200 {
    "application/json": Schemas.Get2UsersIdPinnedListsResponse;
}
export interface Response$listUserPinnedLists$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listUserPin {
    /** The ID of the authenticated source User that will pin the List. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
}
export interface RequestBody$listUserPin {
    "application/json": Schemas.ListPinnedRequest;
}
export interface Response$listUserPin$Status$200 {
    "application/json": Schemas.ListPinnedResponse;
}
export interface Response$listUserPin$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$listUserUnpin {
    /** The ID of the authenticated source User for whom to return results. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The ID of the List to unpin. */
    list_id: Schemas.ListId;
}
export interface Response$listUserUnpin$Status$200 {
    "application/json": Schemas.ListUnpinResponse;
}
export interface Response$listUserUnpin$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdRetweets {
    /** The ID of the authenticated source User that is requesting to retweet the Tweet. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
}
export interface RequestBody$usersIdRetweets {
    "application/json": Schemas.UsersRetweetsCreateRequest;
}
export interface Response$usersIdRetweets$Status$200 {
    "application/json": Schemas.UsersRetweetsCreateResponse;
}
export interface Response$usersIdRetweets$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdUnretweets {
    /** The ID of the authenticated source User that is requesting to retweet the Tweet. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The ID of the Tweet that the User is requesting to unretweet. */
    source_tweet_id: Schemas.TweetId;
}
export interface Response$usersIdUnretweets$Status$200 {
    "application/json": Schemas.UsersRetweetsDeleteResponse;
}
export interface Response$usersIdUnretweets$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdTimeline {
    /** The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. */
    id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. */
    since_id?: Schemas.TweetId;
    /** The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. */
    until_id?: Schemas.TweetId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token?: Schemas.PaginationToken36;
    /** The set of entities to exclude (e.g. 'replies' or 'retweets'). */
    exclude?: ("replies" | "retweets")[];
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. */
    end_time?: string;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$usersIdTimeline$Status$200 {
    "application/json": Schemas.Get2UsersIdTimelinesReverseChronologicalResponse;
}
export interface Response$usersIdTimeline$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdTweets {
    /** The ID of the User to lookup. */
    id: Schemas.UserId;
    /** The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. */
    since_id?: Schemas.TweetId;
    /** The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. */
    until_id?: Schemas.TweetId;
    /** The maximum number of results. */
    max_results?: number;
    /** This parameter is used to get the next 'page' of results. */
    pagination_token?: Schemas.PaginationToken36;
    /** The set of entities to exclude (e.g. 'replies' or 'retweets'). */
    exclude?: ("replies" | "retweets")[];
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. */
    start_time?: string;
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. */
    end_time?: string;
    /** A comma separated list of Tweet fields to display. */
    "tweet.fields"?: Parameters.TweetFieldsParameter;
    /** A comma separated list of fields to expand. */
    expansions?: Parameters.TweetExpansionsParameter;
    /** A comma separated list of Media fields to display. */
    "media.fields"?: Parameters.MediaFieldsParameter;
    /** A comma separated list of Poll fields to display. */
    "poll.fields"?: Parameters.PollFieldsParameter;
    /** A comma separated list of User fields to display. */
    "user.fields"?: Parameters.UserFieldsParameter;
    /** A comma separated list of Place fields to display. */
    "place.fields"?: Parameters.PlaceFieldsParameter;
}
export interface Response$usersIdTweets$Status$200 {
    "application/json": Schemas.Get2UsersIdTweetsResponse;
}
export interface Response$usersIdTweets$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdUnblock {
    /** The ID of the authenticated source User that is requesting to unblock the target User. */
    source_user_id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The ID of the User that the source User is requesting to unblock. */
    target_user_id: Schemas.UserId;
}
export interface Response$usersIdUnblock$Status$200 {
    "application/json": Schemas.BlockUserMutationResponse;
}
export interface Response$usersIdUnblock$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdUnfollow {
    /** The ID of the authenticated source User that is requesting to unfollow the target User. */
    source_user_id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The ID of the User that the source User is requesting to unfollow. */
    target_user_id: Schemas.UserId;
}
export interface Response$usersIdUnfollow$Status$200 {
    "application/json": Schemas.UsersFollowingDeleteResponse;
}
export interface Response$usersIdUnfollow$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export interface Parameter$usersIdUnmute {
    /** The ID of the authenticated source User that is requesting to unmute the target User. */
    source_user_id: Schemas.UserIdMatchesAuthenticatedUser;
    /** The ID of the User that the source User is requesting to unmute. */
    target_user_id: Schemas.UserId;
}
export interface Response$usersIdUnmute$Status$200 {
    "application/json": Schemas.MuteUserMutationResponse;
}
export interface Response$usersIdUnmute$Status$default {
    "application/json": Schemas.Error;
    "application/problem+json": Schemas.Problem;
}
export type ResponseContentType$listBatchComplianceJobs = keyof Response$listBatchComplianceJobs$Status$200;
export interface Params$listBatchComplianceJobs {
    parameter: Parameter$listBatchComplianceJobs;
}
export type RequestContentType$createBatchComplianceJob = keyof RequestBody$createBatchComplianceJob;
export type ResponseContentType$createBatchComplianceJob = keyof Response$createBatchComplianceJob$Status$200;
export interface Params$createBatchComplianceJob {
    requestBody: RequestBody$createBatchComplianceJob["application/json"];
}
export type ResponseContentType$getBatchComplianceJob = keyof Response$getBatchComplianceJob$Status$200;
export interface Params$getBatchComplianceJob {
    parameter: Parameter$getBatchComplianceJob;
}
export type RequestContentType$listIdCreate = keyof RequestBody$listIdCreate;
export type ResponseContentType$listIdCreate = keyof Response$listIdCreate$Status$200;
export interface Params$listIdCreate {
    requestBody: RequestBody$listIdCreate["application/json"];
}
export type ResponseContentType$listIdGet = keyof Response$listIdGet$Status$200;
export interface Params$listIdGet {
    parameter: Parameter$listIdGet;
}
export type RequestContentType$listIdUpdate = keyof RequestBody$listIdUpdate;
export type ResponseContentType$listIdUpdate = keyof Response$listIdUpdate$Status$200;
export interface Params$listIdUpdate {
    parameter: Parameter$listIdUpdate;
    requestBody: RequestBody$listIdUpdate["application/json"];
}
export type ResponseContentType$listIdDelete = keyof Response$listIdDelete$Status$200;
export interface Params$listIdDelete {
    parameter: Parameter$listIdDelete;
}
export type ResponseContentType$listGetFollowers = keyof Response$listGetFollowers$Status$200;
export interface Params$listGetFollowers {
    parameter: Parameter$listGetFollowers;
}
export type ResponseContentType$listGetMembers = keyof Response$listGetMembers$Status$200;
export interface Params$listGetMembers {
    parameter: Parameter$listGetMembers;
}
export type RequestContentType$listAddMember = keyof RequestBody$listAddMember;
export type ResponseContentType$listAddMember = keyof Response$listAddMember$Status$200;
export interface Params$listAddMember {
    parameter: Parameter$listAddMember;
    requestBody: RequestBody$listAddMember["application/json"];
}
export type ResponseContentType$listRemoveMember = keyof Response$listRemoveMember$Status$200;
export interface Params$listRemoveMember {
    parameter: Parameter$listRemoveMember;
}
export type ResponseContentType$listsIdTweets = keyof Response$listsIdTweets$Status$200;
export interface Params$listsIdTweets {
    parameter: Parameter$listsIdTweets;
}
export type ResponseContentType$getOpenApiSpec = keyof Response$getOpenApiSpec$Status$200;
export type ResponseContentType$findSpacesByIds = keyof Response$findSpacesByIds$Status$200;
export interface Params$findSpacesByIds {
    parameter: Parameter$findSpacesByIds;
}
export type ResponseContentType$findSpacesByCreatorIds = keyof Response$findSpacesByCreatorIds$Status$200;
export interface Params$findSpacesByCreatorIds {
    parameter: Parameter$findSpacesByCreatorIds;
}
export type ResponseContentType$searchSpaces = keyof Response$searchSpaces$Status$200;
export interface Params$searchSpaces {
    parameter: Parameter$searchSpaces;
}
export type ResponseContentType$findSpaceById = keyof Response$findSpaceById$Status$200;
export interface Params$findSpaceById {
    parameter: Parameter$findSpaceById;
}
export type ResponseContentType$spaceBuyers = keyof Response$spaceBuyers$Status$200;
export interface Params$spaceBuyers {
    parameter: Parameter$spaceBuyers;
}
export type ResponseContentType$spaceTweets = keyof Response$spaceTweets$Status$200;
export interface Params$spaceTweets {
    parameter: Parameter$spaceTweets;
}
export type ResponseContentType$findTweetsById = keyof Response$findTweetsById$Status$200;
export interface Params$findTweetsById {
    parameter: Parameter$findTweetsById;
}
export type RequestContentType$createTweet = keyof RequestBody$createTweet;
export type ResponseContentType$createTweet = keyof Response$createTweet$Status$201;
export interface Params$createTweet {
    requestBody: RequestBody$createTweet["application/json"];
}
export type ResponseContentType$getTweetsComplianceStream = keyof Response$getTweetsComplianceStream$Status$200;
export interface Params$getTweetsComplianceStream {
    parameter: Parameter$getTweetsComplianceStream;
}
export type ResponseContentType$tweetCountsFullArchiveSearch = keyof Response$tweetCountsFullArchiveSearch$Status$200;
export interface Params$tweetCountsFullArchiveSearch {
    parameter: Parameter$tweetCountsFullArchiveSearch;
}
export type ResponseContentType$tweetCountsRecentSearch = keyof Response$tweetCountsRecentSearch$Status$200;
export interface Params$tweetCountsRecentSearch {
    parameter: Parameter$tweetCountsRecentSearch;
}
export type ResponseContentType$getTweetsFirehoseStream = keyof Response$getTweetsFirehoseStream$Status$200;
export interface Params$getTweetsFirehoseStream {
    parameter: Parameter$getTweetsFirehoseStream;
}
export type ResponseContentType$sampleStream = keyof Response$sampleStream$Status$200;
export interface Params$sampleStream {
    parameter: Parameter$sampleStream;
}
export type ResponseContentType$getTweetsSample10Stream = keyof Response$getTweetsSample10Stream$Status$200;
export interface Params$getTweetsSample10Stream {
    parameter: Parameter$getTweetsSample10Stream;
}
export type ResponseContentType$tweetsFullarchiveSearch = keyof Response$tweetsFullarchiveSearch$Status$200;
export interface Params$tweetsFullarchiveSearch {
    parameter: Parameter$tweetsFullarchiveSearch;
}
export type ResponseContentType$tweetsRecentSearch = keyof Response$tweetsRecentSearch$Status$200;
export interface Params$tweetsRecentSearch {
    parameter: Parameter$tweetsRecentSearch;
}
export type ResponseContentType$searchStream = keyof Response$searchStream$Status$200;
export interface Params$searchStream {
    parameter: Parameter$searchStream;
}
export type ResponseContentType$getRules = keyof Response$getRules$Status$200;
export interface Params$getRules {
    parameter: Parameter$getRules;
}
export type RequestContentType$addOrDeleteRules = keyof RequestBody$addOrDeleteRules;
export type ResponseContentType$addOrDeleteRules = keyof Response$addOrDeleteRules$Status$200;
export interface Params$addOrDeleteRules {
    parameter: Parameter$addOrDeleteRules;
    requestBody: RequestBody$addOrDeleteRules["application/json"];
}
export type ResponseContentType$findTweetById = keyof Response$findTweetById$Status$200;
export interface Params$findTweetById {
    parameter: Parameter$findTweetById;
}
export type ResponseContentType$deleteTweetById = keyof Response$deleteTweetById$Status$200;
export interface Params$deleteTweetById {
    parameter: Parameter$deleteTweetById;
}
export type ResponseContentType$tweetsIdLikingUsers = keyof Response$tweetsIdLikingUsers$Status$200;
export interface Params$tweetsIdLikingUsers {
    parameter: Parameter$tweetsIdLikingUsers;
}
export type ResponseContentType$findTweetsThatQuoteATweet = keyof Response$findTweetsThatQuoteATweet$Status$200;
export interface Params$findTweetsThatQuoteATweet {
    parameter: Parameter$findTweetsThatQuoteATweet;
}
export type ResponseContentType$tweetsIdRetweetingUsers = keyof Response$tweetsIdRetweetingUsers$Status$200;
export interface Params$tweetsIdRetweetingUsers {
    parameter: Parameter$tweetsIdRetweetingUsers;
}
export type RequestContentType$hideReplyById = keyof RequestBody$hideReplyById;
export type ResponseContentType$hideReplyById = keyof Response$hideReplyById$Status$200;
export interface Params$hideReplyById {
    parameter: Parameter$hideReplyById;
    requestBody: RequestBody$hideReplyById["application/json"];
}
export type ResponseContentType$findUsersById = keyof Response$findUsersById$Status$200;
export interface Params$findUsersById {
    parameter: Parameter$findUsersById;
}
export type ResponseContentType$findUsersByUsername = keyof Response$findUsersByUsername$Status$200;
export interface Params$findUsersByUsername {
    parameter: Parameter$findUsersByUsername;
}
export type ResponseContentType$findUserByUsername = keyof Response$findUserByUsername$Status$200;
export interface Params$findUserByUsername {
    parameter: Parameter$findUserByUsername;
}
export type ResponseContentType$getUsersComplianceStream = keyof Response$getUsersComplianceStream$Status$200;
export interface Params$getUsersComplianceStream {
    parameter: Parameter$getUsersComplianceStream;
}
export type ResponseContentType$findMyUser = keyof Response$findMyUser$Status$200;
export interface Params$findMyUser {
    parameter: Parameter$findMyUser;
}
export type ResponseContentType$findUserById = keyof Response$findUserById$Status$200;
export interface Params$findUserById {
    parameter: Parameter$findUserById;
}
export type ResponseContentType$usersIdBlocking = keyof Response$usersIdBlocking$Status$200;
export interface Params$usersIdBlocking {
    parameter: Parameter$usersIdBlocking;
}
export type RequestContentType$usersIdBlock = keyof RequestBody$usersIdBlock;
export type ResponseContentType$usersIdBlock = keyof Response$usersIdBlock$Status$200;
export interface Params$usersIdBlock {
    parameter: Parameter$usersIdBlock;
    requestBody: RequestBody$usersIdBlock["application/json"];
}
export type ResponseContentType$getUsersIdBookmarks = keyof Response$getUsersIdBookmarks$Status$200;
export interface Params$getUsersIdBookmarks {
    parameter: Parameter$getUsersIdBookmarks;
}
export type RequestContentType$postUsersIdBookmarks = keyof RequestBody$postUsersIdBookmarks;
export type ResponseContentType$postUsersIdBookmarks = keyof Response$postUsersIdBookmarks$Status$200;
export interface Params$postUsersIdBookmarks {
    parameter: Parameter$postUsersIdBookmarks;
    requestBody: RequestBody$postUsersIdBookmarks["application/json"];
}
export type ResponseContentType$usersIdBookmarksDelete = keyof Response$usersIdBookmarksDelete$Status$200;
export interface Params$usersIdBookmarksDelete {
    parameter: Parameter$usersIdBookmarksDelete;
}
export type ResponseContentType$userFollowedLists = keyof Response$userFollowedLists$Status$200;
export interface Params$userFollowedLists {
    parameter: Parameter$userFollowedLists;
}
export type RequestContentType$listUserFollow = keyof RequestBody$listUserFollow;
export type ResponseContentType$listUserFollow = keyof Response$listUserFollow$Status$200;
export interface Params$listUserFollow {
    parameter: Parameter$listUserFollow;
    requestBody: RequestBody$listUserFollow["application/json"];
}
export type ResponseContentType$listUserUnfollow = keyof Response$listUserUnfollow$Status$200;
export interface Params$listUserUnfollow {
    parameter: Parameter$listUserUnfollow;
}
export type ResponseContentType$usersIdFollowers = keyof Response$usersIdFollowers$Status$200;
export interface Params$usersIdFollowers {
    parameter: Parameter$usersIdFollowers;
}
export type ResponseContentType$usersIdFollowing = keyof Response$usersIdFollowing$Status$200;
export interface Params$usersIdFollowing {
    parameter: Parameter$usersIdFollowing;
}
export type RequestContentType$usersIdFollow = keyof RequestBody$usersIdFollow;
export type ResponseContentType$usersIdFollow = keyof Response$usersIdFollow$Status$200;
export interface Params$usersIdFollow {
    parameter: Parameter$usersIdFollow;
    requestBody: RequestBody$usersIdFollow["application/json"];
}
export type ResponseContentType$usersIdLikedTweets = keyof Response$usersIdLikedTweets$Status$200;
export interface Params$usersIdLikedTweets {
    parameter: Parameter$usersIdLikedTweets;
}
export type RequestContentType$usersIdLike = keyof RequestBody$usersIdLike;
export type ResponseContentType$usersIdLike = keyof Response$usersIdLike$Status$200;
export interface Params$usersIdLike {
    parameter: Parameter$usersIdLike;
    requestBody: RequestBody$usersIdLike["application/json"];
}
export type ResponseContentType$usersIdUnlike = keyof Response$usersIdUnlike$Status$200;
export interface Params$usersIdUnlike {
    parameter: Parameter$usersIdUnlike;
}
export type ResponseContentType$getUserListMemberships = keyof Response$getUserListMemberships$Status$200;
export interface Params$getUserListMemberships {
    parameter: Parameter$getUserListMemberships;
}
export type ResponseContentType$usersIdMentions = keyof Response$usersIdMentions$Status$200;
export interface Params$usersIdMentions {
    parameter: Parameter$usersIdMentions;
}
export type ResponseContentType$usersIdMuting = keyof Response$usersIdMuting$Status$200;
export interface Params$usersIdMuting {
    parameter: Parameter$usersIdMuting;
}
export type RequestContentType$usersIdMute = keyof RequestBody$usersIdMute;
export type ResponseContentType$usersIdMute = keyof Response$usersIdMute$Status$200;
export interface Params$usersIdMute {
    parameter: Parameter$usersIdMute;
    requestBody: RequestBody$usersIdMute["application/json"];
}
export type ResponseContentType$listUserOwnedLists = keyof Response$listUserOwnedLists$Status$200;
export interface Params$listUserOwnedLists {
    parameter: Parameter$listUserOwnedLists;
}
export type ResponseContentType$listUserPinnedLists = keyof Response$listUserPinnedLists$Status$200;
export interface Params$listUserPinnedLists {
    parameter: Parameter$listUserPinnedLists;
}
export type RequestContentType$listUserPin = keyof RequestBody$listUserPin;
export type ResponseContentType$listUserPin = keyof Response$listUserPin$Status$200;
export interface Params$listUserPin {
    parameter: Parameter$listUserPin;
    requestBody: RequestBody$listUserPin["application/json"];
}
export type ResponseContentType$listUserUnpin = keyof Response$listUserUnpin$Status$200;
export interface Params$listUserUnpin {
    parameter: Parameter$listUserUnpin;
}
export type RequestContentType$usersIdRetweets = keyof RequestBody$usersIdRetweets;
export type ResponseContentType$usersIdRetweets = keyof Response$usersIdRetweets$Status$200;
export interface Params$usersIdRetweets {
    parameter: Parameter$usersIdRetweets;
    requestBody: RequestBody$usersIdRetweets["application/json"];
}
export type ResponseContentType$usersIdUnretweets = keyof Response$usersIdUnretweets$Status$200;
export interface Params$usersIdUnretweets {
    parameter: Parameter$usersIdUnretweets;
}
export type ResponseContentType$usersIdTimeline = keyof Response$usersIdTimeline$Status$200;
export interface Params$usersIdTimeline {
    parameter: Parameter$usersIdTimeline;
}
export type ResponseContentType$usersIdTweets = keyof Response$usersIdTweets$Status$200;
export interface Params$usersIdTweets {
    parameter: Parameter$usersIdTweets;
}
export type ResponseContentType$usersIdUnblock = keyof Response$usersIdUnblock$Status$200;
export interface Params$usersIdUnblock {
    parameter: Parameter$usersIdUnblock;
}
export type ResponseContentType$usersIdUnfollow = keyof Response$usersIdUnfollow$Status$200;
export interface Params$usersIdUnfollow {
    parameter: Parameter$usersIdUnfollow;
}
export type ResponseContentType$usersIdUnmute = keyof Response$usersIdUnmute$Status$200;
export interface Params$usersIdUnmute {
    parameter: Parameter$usersIdUnmute;
}
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$listBatchComplianceJobs$Status$200 | Response$createBatchComplianceJob$Status$200 | Response$getBatchComplianceJob$Status$200 | Response$listIdCreate$Status$200 | Response$listIdGet$Status$200 | Response$listIdUpdate$Status$200 | Response$listIdDelete$Status$200 | Response$listGetFollowers$Status$200 | Response$listGetMembers$Status$200 | Response$listAddMember$Status$200 | Response$listRemoveMember$Status$200 | Response$listsIdTweets$Status$200 | Response$getOpenApiSpec$Status$200 | Response$findSpacesByIds$Status$200 | Response$findSpacesByCreatorIds$Status$200 | Response$searchSpaces$Status$200 | Response$findSpaceById$Status$200 | Response$spaceBuyers$Status$200 | Response$spaceTweets$Status$200 | Response$findTweetsById$Status$200 | Response$createTweet$Status$201 | Response$getTweetsComplianceStream$Status$200 | Response$tweetCountsFullArchiveSearch$Status$200 | Response$tweetCountsRecentSearch$Status$200 | Response$getTweetsFirehoseStream$Status$200 | Response$sampleStream$Status$200 | Response$getTweetsSample10Stream$Status$200 | Response$tweetsFullarchiveSearch$Status$200 | Response$tweetsRecentSearch$Status$200 | Response$searchStream$Status$200 | Response$getRules$Status$200 | Response$addOrDeleteRules$Status$200 | Response$findTweetById$Status$200 | Response$deleteTweetById$Status$200 | Response$tweetsIdLikingUsers$Status$200 | Response$findTweetsThatQuoteATweet$Status$200 | Response$tweetsIdRetweetingUsers$Status$200 | Response$hideReplyById$Status$200 | Response$findUsersById$Status$200 | Response$findUsersByUsername$Status$200 | Response$findUserByUsername$Status$200 | Response$getUsersComplianceStream$Status$200 | Response$findMyUser$Status$200 | Response$findUserById$Status$200 | Response$usersIdBlocking$Status$200 | Response$usersIdBlock$Status$200 | Response$getUsersIdBookmarks$Status$200 | Response$postUsersIdBookmarks$Status$200 | Response$usersIdBookmarksDelete$Status$200 | Response$userFollowedLists$Status$200 | Response$listUserFollow$Status$200 | Response$listUserUnfollow$Status$200 | Response$usersIdFollowers$Status$200 | Response$usersIdFollowing$Status$200 | Response$usersIdFollow$Status$200 | Response$usersIdLikedTweets$Status$200 | Response$usersIdLike$Status$200 | Response$usersIdUnlike$Status$200 | Response$getUserListMemberships$Status$200 | Response$usersIdMentions$Status$200 | Response$usersIdMuting$Status$200 | Response$usersIdMute$Status$200 | Response$listUserOwnedLists$Status$200 | Response$listUserPinnedLists$Status$200 | Response$listUserPin$Status$200 | Response$listUserUnpin$Status$200 | Response$usersIdRetweets$Status$200 | Response$usersIdUnretweets$Status$200 | Response$usersIdTimeline$Status$200 | Response$usersIdTweets$Status$200 | Response$usersIdUnblock$Status$200 | Response$usersIdUnfollow$Status$200 | Response$usersIdUnmute$Status$200;
export namespace ErrorResponse {
    export type listBatchComplianceJobs = void;
    export type createBatchComplianceJob = void;
    export type getBatchComplianceJob = void;
    export type listIdCreate = void;
    export type listIdGet = void;
    export type listIdUpdate = void;
    export type listIdDelete = void;
    export type listGetFollowers = void;
    export type listGetMembers = void;
    export type listAddMember = void;
    export type listRemoveMember = void;
    export type listsIdTweets = void;
    export type getOpenApiSpec = void;
    export type findSpacesByIds = void;
    export type findSpacesByCreatorIds = void;
    export type searchSpaces = void;
    export type findSpaceById = void;
    export type spaceBuyers = void;
    export type spaceTweets = void;
    export type findTweetsById = void;
    export type createTweet = void;
    export type getTweetsComplianceStream = void;
    export type tweetCountsFullArchiveSearch = void;
    export type tweetCountsRecentSearch = void;
    export type getTweetsFirehoseStream = void;
    export type sampleStream = void;
    export type getTweetsSample10Stream = void;
    export type tweetsFullarchiveSearch = void;
    export type tweetsRecentSearch = void;
    export type searchStream = void;
    export type getRules = void;
    export type addOrDeleteRules = void;
    export type findTweetById = void;
    export type deleteTweetById = void;
    export type tweetsIdLikingUsers = void;
    export type findTweetsThatQuoteATweet = void;
    export type tweetsIdRetweetingUsers = void;
    export type hideReplyById = void;
    export type findUsersById = void;
    export type findUsersByUsername = void;
    export type findUserByUsername = void;
    export type getUsersComplianceStream = void;
    export type findMyUser = void;
    export type findUserById = void;
    export type usersIdBlocking = void;
    export type usersIdBlock = void;
    export type getUsersIdBookmarks = void;
    export type postUsersIdBookmarks = void;
    export type usersIdBookmarksDelete = void;
    export type userFollowedLists = void;
    export type listUserFollow = void;
    export type listUserUnfollow = void;
    export type usersIdFollowers = void;
    export type usersIdFollowing = void;
    export type usersIdFollow = void;
    export type usersIdLikedTweets = void;
    export type usersIdLike = void;
    export type usersIdUnlike = void;
    export type getUserListMemberships = void;
    export type usersIdMentions = void;
    export type usersIdMuting = void;
    export type usersIdMute = void;
    export type listUserOwnedLists = void;
    export type listUserPinnedLists = void;
    export type listUserPin = void;
    export type listUserUnpin = void;
    export type usersIdRetweets = void;
    export type usersIdUnretweets = void;
    export type usersIdTimeline = void;
    export type usersIdTweets = void;
    export type usersIdUnblock = void;
    export type usersIdUnfollow = void;
    export type usersIdUnmute = void;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(httpMethod: HttpMethod, url: string, headers: ObjectLike | any, requestBody: ObjectLike | any, queryParameters: QueryParameters | undefined, options?: RequestOption) => Promise<T>;
}
export class Client<RequestOption> {
    private baseUrl: string;
    constructor(private apiClient: ApiClient<RequestOption>, baseUrl: string) { this.baseUrl = baseUrl.replace(/\/$/, ""); }
    /**
     * List Compliance Jobs
     * Returns recent Compliance Jobs for a given job type and optional job status
     */
    public async listBatchComplianceJobs(params: Params$listBatchComplianceJobs, option?: RequestOption): Promise<Response$listBatchComplianceJobs$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/compliance/jobs`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            type: { value: params.parameter.type, style: "form", explode: false },
            status: { value: params.parameter.status, style: "form", explode: false },
            "compliance_job.fields": { value: params.parameter["compliance_job.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create compliance job
     * Creates a compliance for the given job type
     */
    public async createBatchComplianceJob(params: Params$createBatchComplianceJob, option?: RequestOption): Promise<Response$createBatchComplianceJob$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/compliance/jobs`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get Compliance Job
     * Returns a single Compliance Job by ID
     */
    public async getBatchComplianceJob(params: Params$getBatchComplianceJob, option?: RequestOption): Promise<Response$getBatchComplianceJob$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/compliance/jobs/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "compliance_job.fields": { value: params.parameter["compliance_job.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Create List
     * Creates a new List.
     */
    public async listIdCreate(params: Params$listIdCreate, option?: RequestOption): Promise<Response$listIdCreate$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/lists`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * List lookup by List ID.
     * Returns a List.
     */
    public async listIdGet(params: Params$listIdGet, option?: RequestOption): Promise<Response$listIdGet$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/lists/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "list.fields": { value: params.parameter["list.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Update List.
     * Update a List that you own.
     */
    public async listIdUpdate(params: Params$listIdUpdate, option?: RequestOption): Promise<Response$listIdUpdate$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/lists/${params.parameter.id}`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Delete List
     * Delete a List that you own.
     */
    public async listIdDelete(params: Params$listIdDelete, option?: RequestOption): Promise<Response$listIdDelete$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/lists/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Returns User objects that follow a List by the provided List ID
     * Returns a list of Users that follow a List by the provided List ID
     */
    public async listGetFollowers(params: Params$listGetFollowers, option?: RequestOption): Promise<Response$listGetFollowers$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/lists/${params.parameter.id}/followers`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns User objects that are members of a List by the provided List ID.
     * Returns a list of Users that are members of a List by the provided List ID.
     */
    public async listGetMembers(params: Params$listGetMembers, option?: RequestOption): Promise<Response$listGetMembers$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/lists/${params.parameter.id}/members`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Add a List member
     * Causes a User to become a member of a List.
     */
    public async listAddMember(params: Params$listAddMember, option?: RequestOption): Promise<Response$listAddMember$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/lists/${params.parameter.id}/members`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Remove a List member
     * Causes a User to be removed from the members of a List.
     */
    public async listRemoveMember(params: Params$listRemoveMember, option?: RequestOption): Promise<Response$listRemoveMember$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/lists/${params.parameter.id}/members/${params.parameter.user_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * List Tweets timeline by List ID.
     * Returns a list of Tweets associated with the provided List ID.
     */
    public async listsIdTweets(params: Params$listsIdTweets, option?: RequestOption): Promise<Response$listsIdTweets$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/lists/${params.parameter.id}/tweets`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns the OpenAPI Specification document.
     * Full OpenAPI Specification in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     */
    public async getOpenApiSpec(option?: RequestOption): Promise<Response$getOpenApiSpec$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/openapi.json`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("GET", url, headers, undefined, undefined, option);
    }
    /**
     * Space lookup up Space IDs
     * Returns a variety of information about the Spaces specified by the requested IDs
     */
    public async findSpacesByIds(params: Params$findSpacesByIds, option?: RequestOption): Promise<Response$findSpacesByIds$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/spaces`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ids: { value: params.parameter.ids, style: "form", explode: false },
            "space.fields": { value: params.parameter["space.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "topic.fields": { value: params.parameter["topic.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Space lookup by their creators
     * Returns a variety of information about the Spaces created by the provided User IDs
     */
    public async findSpacesByCreatorIds(params: Params$findSpacesByCreatorIds, option?: RequestOption): Promise<Response$findSpacesByCreatorIds$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/spaces/by/creator_ids`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            user_ids: { value: params.parameter.user_ids, style: "form", explode: false },
            "space.fields": { value: params.parameter["space.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "topic.fields": { value: params.parameter["topic.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Search for Spaces
     * Returns Spaces that match the provided query.
     */
    public async searchSpaces(params: Params$searchSpaces, option?: RequestOption): Promise<Response$searchSpaces$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/spaces/search`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            query: { value: params.parameter.query, style: "form", explode: false },
            state: { value: params.parameter.state, style: "form", explode: false },
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            "space.fields": { value: params.parameter["space.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "topic.fields": { value: params.parameter["topic.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Space lookup by Space ID
     * Returns a variety of information about the Space specified by the requested ID
     */
    public async findSpaceById(params: Params$findSpaceById, option?: RequestOption): Promise<Response$findSpaceById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/spaces/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "space.fields": { value: params.parameter["space.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "topic.fields": { value: params.parameter["topic.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Retrieve the list of Users who purchased a ticket to the given space
     * Retrieves the list of Users who purchased a ticket to the given space
     */
    public async spaceBuyers(params: Params$spaceBuyers, option?: RequestOption): Promise<Response$spaceBuyers$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/spaces/${params.parameter.id}/buyers`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Retrieve Tweets from a Space.
     * Retrieves Tweets shared in the specified Space.
     */
    public async spaceTweets(params: Params$spaceTweets, option?: RequestOption): Promise<Response$spaceTweets$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/spaces/${params.parameter.id}/tweets`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Tweet lookup by Tweet IDs
     * Returns a variety of information about the Tweet specified by the requested ID.
     */
    public async findTweetsById(params: Params$findTweetsById, option?: RequestOption): Promise<Response$findTweetsById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ids: { value: params.parameter.ids, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Creation of a Tweet
     * Causes the User to create a Tweet under the authorized account.
     */
    public async createTweet(params: Params$createTweet, option?: RequestOption): Promise<Response$createTweet$Status$201["application/json"]> {
        const url = this.baseUrl + `/2/tweets`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Tweets Compliance stream
     * Streams 100% of compliance data for Tweets
     */
    public async getTweetsComplianceStream(params: Params$getTweetsComplianceStream, option?: RequestOption): Promise<Response$getTweetsComplianceStream$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/compliance/stream`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            backfill_minutes: { value: params.parameter.backfill_minutes, style: "form", explode: false },
            partition: { value: params.parameter.partition, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Full archive search counts
     * Returns Tweet Counts that match a search query.
     */
    public async tweetCountsFullArchiveSearch(params: Params$tweetCountsFullArchiveSearch, option?: RequestOption): Promise<Response$tweetCountsFullArchiveSearch$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/counts/all`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            query: { value: params.parameter.query, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            since_id: { value: params.parameter.since_id, style: "form", explode: false },
            until_id: { value: params.parameter.until_id, style: "form", explode: false },
            next_token: { value: params.parameter.next_token, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            granularity: { value: params.parameter.granularity, style: "form", explode: false },
            "search_count.fields": { value: params.parameter["search_count.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Recent search counts
     * Returns Tweet Counts from the last 7 days that match a search query.
     */
    public async tweetCountsRecentSearch(params: Params$tweetCountsRecentSearch, option?: RequestOption): Promise<Response$tweetCountsRecentSearch$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/counts/recent`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            query: { value: params.parameter.query, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            since_id: { value: params.parameter.since_id, style: "form", explode: false },
            until_id: { value: params.parameter.until_id, style: "form", explode: false },
            next_token: { value: params.parameter.next_token, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            granularity: { value: params.parameter.granularity, style: "form", explode: false },
            "search_count.fields": { value: params.parameter["search_count.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Firehose stream
     * Streams 100% of public Tweets.
     */
    public async getTweetsFirehoseStream(params: Params$getTweetsFirehoseStream, option?: RequestOption): Promise<Response$getTweetsFirehoseStream$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/firehose/stream`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            backfill_minutes: { value: params.parameter.backfill_minutes, style: "form", explode: false },
            partition: { value: params.parameter.partition, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Sample stream
     * Streams a deterministic 1% of public Tweets.
     */
    public async sampleStream(params: Params$sampleStream, option?: RequestOption): Promise<Response$sampleStream$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/sample/stream`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            backfill_minutes: { value: params.parameter.backfill_minutes, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Sample 10% stream
     * Streams a deterministic 10% of public Tweets.
     */
    public async getTweetsSample10Stream(params: Params$getTweetsSample10Stream, option?: RequestOption): Promise<Response$getTweetsSample10Stream$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/sample10/stream`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            backfill_minutes: { value: params.parameter.backfill_minutes, style: "form", explode: false },
            partition: { value: params.parameter.partition, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Full-archive search
     * Returns Tweets that match a search query.
     */
    public async tweetsFullarchiveSearch(params: Params$tweetsFullarchiveSearch, option?: RequestOption): Promise<Response$tweetsFullarchiveSearch$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/all`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            query: { value: params.parameter.query, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            since_id: { value: params.parameter.since_id, style: "form", explode: false },
            until_id: { value: params.parameter.until_id, style: "form", explode: false },
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            next_token: { value: params.parameter.next_token, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            sort_order: { value: params.parameter.sort_order, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Recent search
     * Returns Tweets from the last 7 days that match a search query.
     */
    public async tweetsRecentSearch(params: Params$tweetsRecentSearch, option?: RequestOption): Promise<Response$tweetsRecentSearch$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/recent`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            query: { value: params.parameter.query, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            since_id: { value: params.parameter.since_id, style: "form", explode: false },
            until_id: { value: params.parameter.until_id, style: "form", explode: false },
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            next_token: { value: params.parameter.next_token, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            sort_order: { value: params.parameter.sort_order, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Filtered stream
     * Streams Tweets matching the stream's active rule set.
     */
    public async searchStream(params: Params$searchStream, option?: RequestOption): Promise<Response$searchStream$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/stream`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            backfill_minutes: { value: params.parameter.backfill_minutes, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Rules lookup
     * Returns rules from a User's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     */
    public async getRules(params: Params$getRules, option?: RequestOption): Promise<Response$getRules$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/stream/rules`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ids: { value: params.parameter.ids, style: "form", explode: false },
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Add/Delete rules
     * Add or delete rules from a User's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     */
    public async addOrDeleteRules(params: Params$addOrDeleteRules, option?: RequestOption): Promise<Response$addOrDeleteRules$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/search/stream/rules`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            dry_run: { value: params.parameter.dry_run, style: "form", explode: false }
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, queryParameters, option);
    }
    /**
     * Tweet lookup by Tweet ID
     * Returns a variety of information about the Tweet specified by the requested ID.
     */
    public async findTweetById(params: Params$findTweetById, option?: RequestOption): Promise<Response$findTweetById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Tweet delete by Tweet ID
     * Delete specified Tweet (in the path) by ID.
     */
    public async deleteTweetById(params: Params$deleteTweetById, option?: RequestOption): Promise<Response$deleteTweetById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Returns User objects that have liked the provided Tweet ID
     * Returns a list of Users that have liked the provided Tweet ID
     */
    public async tweetsIdLikingUsers(params: Params$tweetsIdLikingUsers, option?: RequestOption): Promise<Response$tweetsIdLikingUsers$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/${params.parameter.id}/liking_users`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Retrieve Tweets that quote a Tweet.
     * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
     */
    public async findTweetsThatQuoteATweet(params: Params$findTweetsThatQuoteATweet, option?: RequestOption): Promise<Response$findTweetsThatQuoteATweet$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/${params.parameter.id}/quote_tweets`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            exclude: { value: params.parameter.exclude, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns User objects that have retweeted the provided Tweet ID
     * Returns a list of Users that have retweeted the provided Tweet ID
     */
    public async tweetsIdRetweetingUsers(params: Params$tweetsIdRetweetingUsers, option?: RequestOption): Promise<Response$tweetsIdRetweetingUsers$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/${params.parameter.id}/retweeted_by`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Hide replies
     * Hides or unhides a reply to an owned conversation.
     */
    public async hideReplyById(params: Params$hideReplyById, option?: RequestOption): Promise<Response$hideReplyById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/tweets/${params.parameter.tweet_id}/hidden`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("PUT", url, headers, params.requestBody, undefined, option);
    }
    /**
     * User lookup by IDs
     * This endpoint returns information about Users. Specify Users by their ID.
     */
    public async findUsersById(params: Params$findUsersById, option?: RequestOption): Promise<Response$findUsersById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            ids: { value: params.parameter.ids, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * User lookup by usernames
     * This endpoint returns information about Users. Specify Users by their username.
     */
    public async findUsersByUsername(params: Params$findUsersByUsername, option?: RequestOption): Promise<Response$findUsersByUsername$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/by`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            usernames: { value: params.parameter.usernames, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * User lookup by username
     * This endpoint returns information about a User. Specify User by username.
     */
    public async findUserByUsername(params: Params$findUserByUsername, option?: RequestOption): Promise<Response$findUserByUsername$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/by/username/${params.parameter.username}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Users Compliance stream
     * Streams 100% of compliance data for Users
     */
    public async getUsersComplianceStream(params: Params$getUsersComplianceStream, option?: RequestOption): Promise<Response$getUsersComplianceStream$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/compliance/stream`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            backfill_minutes: { value: params.parameter.backfill_minutes, style: "form", explode: false },
            partition: { value: params.parameter.partition, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * User lookup me
     * This endpoint returns information about the requesting User.
     */
    public async findMyUser(params: Params$findMyUser, option?: RequestOption): Promise<Response$findMyUser$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/me`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * User lookup by ID
     * This endpoint returns information about a User. Specify User by ID.
     */
    public async findUserById(params: Params$findUserById, option?: RequestOption): Promise<Response$findUserById$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns User objects that are blocked by provided User ID
     * Returns a list of Users that are blocked by the provided User ID
     */
    public async usersIdBlocking(params: Params$usersIdBlocking, option?: RequestOption): Promise<Response$usersIdBlocking$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/blocking`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Block User by User ID
     * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
     */
    public async usersIdBlock(params: Params$usersIdBlock, option?: RequestOption): Promise<Response$usersIdBlock$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/blocking`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Bookmarks by User
     * Returns Tweet objects that have been bookmarked by the requesting User
     */
    public async getUsersIdBookmarks(params: Params$getUsersIdBookmarks, option?: RequestOption): Promise<Response$getUsersIdBookmarks$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/bookmarks`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Add Tweet to Bookmarks
     * Adds a Tweet (ID in the body) to the requesting User's (in the path) bookmarks
     */
    public async postUsersIdBookmarks(params: Params$postUsersIdBookmarks, option?: RequestOption): Promise<Response$postUsersIdBookmarks$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/bookmarks`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Remove a bookmarked Tweet
     * Removes a Tweet from the requesting User's bookmarked Tweets.
     */
    public async usersIdBookmarksDelete(params: Params$usersIdBookmarksDelete, option?: RequestOption): Promise<Response$usersIdBookmarksDelete$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/bookmarks/${params.parameter.tweet_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Get User's Followed Lists
     * Returns a User's followed Lists.
     */
    public async userFollowedLists(params: Params$userFollowedLists, option?: RequestOption): Promise<Response$userFollowedLists$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/followed_lists`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "list.fields": { value: params.parameter["list.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Follow a List
     * Causes a User to follow a List.
     */
    public async listUserFollow(params: Params$listUserFollow, option?: RequestOption): Promise<Response$listUserFollow$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/followed_lists`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Unfollow a List
     * Causes a User to unfollow a List.
     */
    public async listUserUnfollow(params: Params$listUserUnfollow, option?: RequestOption): Promise<Response$listUserUnfollow$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/followed_lists/${params.parameter.list_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Followers by User ID
     * Returns a list of Users who are followers of the specified User ID.
     */
    public async usersIdFollowers(params: Params$usersIdFollowers, option?: RequestOption): Promise<Response$usersIdFollowers$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/followers`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Following by User ID
     * Returns a list of Users that are being followed by the provided User ID
     */
    public async usersIdFollowing(params: Params$usersIdFollowing, option?: RequestOption): Promise<Response$usersIdFollowing$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/following`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Follow User
     * Causes the User(in the path) to follow, or request to follow for protected Users, the target User. The User(in the path) must match the User context authorizing the request
     */
    public async usersIdFollow(params: Params$usersIdFollow, option?: RequestOption): Promise<Response$usersIdFollow$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/following`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Returns Tweet objects liked by the provided User ID
     * Returns a list of Tweets liked by the provided User ID
     */
    public async usersIdLikedTweets(params: Params$usersIdLikedTweets, option?: RequestOption): Promise<Response$usersIdLikedTweets$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/liked_tweets`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Causes the User (in the path) to like the specified Tweet
     * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
     */
    public async usersIdLike(params: Params$usersIdLike, option?: RequestOption): Promise<Response$usersIdLike$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/likes`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Causes the User (in the path) to unlike the specified Tweet
     * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
     */
    public async usersIdUnlike(params: Params$usersIdUnlike, option?: RequestOption): Promise<Response$usersIdUnlike$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/likes/${params.parameter.tweet_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Get a User's List Memberships
     * Get a User's List Memberships.
     */
    public async getUserListMemberships(params: Params$getUserListMemberships, option?: RequestOption): Promise<Response$getUserListMemberships$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/list_memberships`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "list.fields": { value: params.parameter["list.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * User mention timeline by User ID
     * Returns Tweet objects that mention username associated to the provided User ID
     */
    public async usersIdMentions(params: Params$usersIdMentions, option?: RequestOption): Promise<Response$usersIdMentions$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/mentions`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            since_id: { value: params.parameter.since_id, style: "form", explode: false },
            until_id: { value: params.parameter.until_id, style: "form", explode: false },
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Returns User objects that are muted by the provided User ID
     * Returns a list of Users that are muted by the provided User ID
     */
    public async usersIdMuting(params: Params$usersIdMuting, option?: RequestOption): Promise<Response$usersIdMuting$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/muting`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Mute User by User ID.
     * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
     */
    public async usersIdMute(params: Params$usersIdMute, option?: RequestOption): Promise<Response$usersIdMute$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/muting`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Get a User's Owned Lists.
     * Get a User's Owned Lists.
     */
    public async listUserOwnedLists(params: Params$listUserOwnedLists, option?: RequestOption): Promise<Response$listUserOwnedLists$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/owned_lists`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            "list.fields": { value: params.parameter["list.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Get a User's Pinned Lists
     * Get a User's Pinned Lists.
     */
    public async listUserPinnedLists(params: Params$listUserPinnedLists, option?: RequestOption): Promise<Response$listUserPinnedLists$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/pinned_lists`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            "list.fields": { value: params.parameter["list.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Pin a List
     * Causes a User to pin a List.
     */
    public async listUserPin(params: Params$listUserPin, option?: RequestOption): Promise<Response$listUserPin$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/pinned_lists`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Unpin a List
     * Causes a User to remove a pinned List.
     */
    public async listUserUnpin(params: Params$listUserUnpin, option?: RequestOption): Promise<Response$listUserUnpin$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/pinned_lists/${params.parameter.list_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Causes the User (in the path) to retweet the specified Tweet.
     * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
     */
    public async usersIdRetweets(params: Params$usersIdRetweets, option?: RequestOption): Promise<Response$usersIdRetweets$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/retweets`;
        const headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
        };
        return this.apiClient.request("POST", url, headers, params.requestBody, undefined, option);
    }
    /**
     * Causes the User (in the path) to unretweet the specified Tweet
     * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
     */
    public async usersIdUnretweets(params: Params$usersIdUnretweets, option?: RequestOption): Promise<Response$usersIdUnretweets$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/retweets/${params.parameter.source_tweet_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * User home timeline by User ID
     * Returns Tweet objects that appears in the provided User ID's home timeline
     */
    public async usersIdTimeline(params: Params$usersIdTimeline, option?: RequestOption): Promise<Response$usersIdTimeline$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/timelines/reverse_chronological`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            since_id: { value: params.parameter.since_id, style: "form", explode: false },
            until_id: { value: params.parameter.until_id, style: "form", explode: false },
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            exclude: { value: params.parameter.exclude, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * User Tweets timeline by User ID
     * Returns a list of Tweets authored by the provided User ID
     */
    public async usersIdTweets(params: Params$usersIdTweets, option?: RequestOption): Promise<Response$usersIdTweets$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.id}/tweets`;
        const headers = {
            Accept: "application/json"
        };
        const queryParameters: QueryParameters = {
            since_id: { value: params.parameter.since_id, style: "form", explode: false },
            until_id: { value: params.parameter.until_id, style: "form", explode: false },
            max_results: { value: params.parameter.max_results, style: "form", explode: false },
            pagination_token: { value: params.parameter.pagination_token, style: "form", explode: false },
            exclude: { value: params.parameter.exclude, style: "form", explode: false },
            start_time: { value: params.parameter.start_time, style: "form", explode: false },
            end_time: { value: params.parameter.end_time, style: "form", explode: false },
            "tweet.fields": { value: params.parameter["tweet.fields"], style: "form", explode: false },
            expansions: { value: params.parameter.expansions, style: "form", explode: false },
            "media.fields": { value: params.parameter["media.fields"], style: "form", explode: false },
            "poll.fields": { value: params.parameter["poll.fields"], style: "form", explode: false },
            "user.fields": { value: params.parameter["user.fields"], style: "form", explode: false },
            "place.fields": { value: params.parameter["place.fields"], style: "form", explode: false }
        };
        return this.apiClient.request("GET", url, headers, undefined, queryParameters, option);
    }
    /**
     * Unblock User by User ID
     * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
     */
    public async usersIdUnblock(params: Params$usersIdUnblock, option?: RequestOption): Promise<Response$usersIdUnblock$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.source_user_id}/blocking/${params.parameter.target_user_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Unfollow User
     * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
     */
    public async usersIdUnfollow(params: Params$usersIdUnfollow, option?: RequestOption): Promise<Response$usersIdUnfollow$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.source_user_id}/following/${params.parameter.target_user_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
    /**
     * Unmute User by User ID
     * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
     */
    public async usersIdUnmute(params: Params$usersIdUnmute, option?: RequestOption): Promise<Response$usersIdUnmute$Status$200["application/json"]> {
        const url = this.baseUrl + `/2/users/${params.parameter.source_user_id}/muting/${params.parameter.target_user_id}`;
        const headers = {
            Accept: "application/json"
        };
        return this.apiClient.request("DELETE", url, headers, undefined, undefined, option);
    }
}
